<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>nested(嵌套)数据类型 | ElasticSearch 7.7 权威指南中文版</title>
	<meta name="keywords" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <meta name="description" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
	<link rel="stylesheet" type="text/css" href="../static/styles.css" />
	<script>
	var _link = 'nested.html';
    </script>
</head>
<body>
<div class="main-container">
    <section id="content">
        <div class="content-wrapper">
            <section id="guide" lang="zh_cn">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                            <div style="color:gray; word-break: break-all; font-size:12px;">原英文版地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/nested.html" rel="nofollow" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/7.7/nested.html</a>, 原文档版权归 www.elastic.co 所有<br/>本地英文版地址: <a href="../en/nested.html" rel="nofollow" target="_blank">../en/nested.html</a></div>
                        <!-- start body -->
                  <div class="page_header">
<strong>重要</strong>: 此版本不会发布额外的bug修复或文档更新。最新信息请参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="nofollow">当前版本文档</a>。
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch 权威指南 [7.7]</a></span>
»
<span class="breadcrumb-link"><a href="mapping.html">映射</a></span>
»
<span class="breadcrumb-link"><a href="mapping-types.html">字段数据类型</a></span>
»
<span class="breadcrumb-node">nested(嵌套)数据类型</span>
</div>
<div class="navheader">
<span class="prev">
<a href="keyword.html">« keyword(关键词)数据类型</a>
</span>
<span class="next">
<a href2="number.html">Numeric datatypes »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title">
<a id="nested"></a>nested(嵌套)数据类型
</h2>
</div></div></div>

<p><code class="literal">nested</code>类型是<a class="xref" href="object.html" title="object数据类型" rel="nofollow"><code class="literal">object</code></a>数据类型的一个特殊版本，它允许以一种可以相互独立查询的方式对对象数组进行索引。</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>
当摄入包含大量任意键的键值对时，可以考虑将每个键值对建模为包含<code class="literal">key</code>和<code class="literal">value</code>字段的嵌套文档。

相反，可以考虑使用<a class="xref" href="flattened.html" title="Flattened datatype">flattened</a>数据类型，它将整个对象映射为单个字段，并允许对其内容进行简单的搜索。

嵌套的文档及其查询的代价通常是很高的，因此对于这个用例使用<code class="literal">flattened</code>数据类型是一个更好的选择。
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="nested-arrays-flattening-objects"></a>对象数组是如何扁平化的?
</h3>
</div></div></div>
<p>
Elasticsearch没有内部对象的概念。

因此，它将对象层次结构简化为字段名称和值的简单列表。

例如，考虑以下文档：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [ <a id="CO306-1"></a><i class="conum" data-value="1"></i>
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/671.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO306-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>字段<code class="literal">user</code>是自动添加的，其字段类型为<code class="literal">object</code>。</p>
</td>
</tr>
</table>
</div>
<p>上面的文档将在内部转换成如下所示的文档：</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "group" :        "fans",
  "user.first" : [ "alice", "john" ],
  "user.last" :  [ "smith", "white" ]
}</pre>
</div>
<p>
<code class="literal">user.first</code>和<code class="literal">user.last</code>字段被展平为多值字段，<code class="literal">alice</code>和<code class="literal">white</code>之间的关联丢失。

该文档将错误地匹配查询<code class="literal">alice AND smith</code>：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my_index/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "user.first": "Alice" }},
        { "match": { "user.last":  "Smith" }}
      ]
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/672.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="nested-fields-array-objects"></a>将<code class="literal">nested</code>字段用于对象数组
</h3>
</div></div></div>
<p>如果需要索引对象数组并保持数组中每个对象的独立性，请使用<code class="literal">nested</code>数据类型而不是<a class="xref" href="object.html" title="object数据类型" rel="nofollow"><code class="literal">object</code></a>数据类型。</p>
<p>在内部，嵌套对象将数组中的每个对象作为单独的隐藏文档进行索引，这意味着可以使用<a class="xref" href="query-dsl-nested-query.html" title="嵌套查询"><code class="literal">nested</code>查询</a>独立于其他对象来查询每个嵌套对象：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my_index
{
  "mappings": {
    "properties": {
      "user": {
        "type": "nested" <a id="CO307-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}

PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}

GET my_index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "Smith" }} <a id="CO307-2"></a><i class="conum" data-value="2"></i>
          ]
        }
      }
    }
  }
}

GET my_index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "White" }} <a id="CO307-3"></a><i class="conum" data-value="3"></i>
          ]
        }
      },
      "inner_hits": { <a id="CO307-4"></a><i class="conum" data-value="4"></i>
        "highlight": {
          "fields": {
            "user.first": {}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/673.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO307-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>字段<code class="literal">user</code>被映射为<code class="literal">nested</code>类型，而不是<code class="literal">object</code>。</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO307-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>这个查询不能匹配（该文档），因为<code class="literal">Alice</code>和<code class="literal">Smith</code>不是在同一个嵌套对象里。</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO307-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>这个查询能匹配，因为<code class="literal">Alice</code>和<code class="literal">White</code>是在同一个嵌套对象里。</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO307-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">inner_hits</code>允许突出显示匹配的嵌套文档。</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="nested-accessing-documents"></a>与<code class="literal">nested</code>文档交互
</h3>
</div></div></div>
<p>Nested documents can be:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
queried with the <a class="xref" href="query-dsl-nested-query.html" title="Nested query"><code class="literal">nested</code></a> query.
</li>
<li class="listitem">
analyzed with the <a class="xref" href="search-aggregations-bucket-nested-aggregation.html" title="Nested Aggregation"><code class="literal">nested</code></a>
and <a class="xref" href="search-aggregations-bucket-reverse-nested-aggregation.html" title="Reverse nested Aggregation"><code class="literal">reverse_nested</code></a>
aggregations.
</li>
<li class="listitem">
sorted with <a class="xref" href="search-request-body.html#nested-sorting" title="Sorting within nested objects.">nested sorting</a>.
</li>
<li class="listitem">
retrieved and highlighted with <a class="xref" href="search-request-body.html#nested-inner-hits" title="Nested inner hits">nested inner hits</a>.
</li>
</ul>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>Because nested documents are indexed as separate documents, they can only be
accessed  within the scope of the <code class="literal">nested</code> query, the
<code class="literal">nested</code>/<code class="literal">reverse_nested</code> aggregations, or <a class="xref" href="search-request-body.html#nested-inner-hits" title="Nested inner hits">nested inner hits</a>.</p>
<p>For instance, if a string field within a nested document has
<a class="xref" href="index-options.html" title="index_options"><code class="literal">index_options</code></a> set to <code class="literal">offsets</code> to allow use of the postings
during the highlighting, these offsets will not be available during the main highlighting
phase.  Instead, highlighting needs to be performed via
<a class="xref" href="search-request-body.html#nested-inner-hits" title="Nested inner hits">nested inner hits</a>. The same consideration applies when loading
fields during a search through <a class="xref" href="run-a-search.html#docvalue-fields" title="Doc value fields"><code class="literal">docvalue_fields</code></a> or <a class="xref" href="search-request-body.html#request-body-search-stored-fields" title="Stored Fields"><code class="literal">stored_fields</code></a>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="nested-params"></a>Parameters for <code class="literal">nested</code> fields<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/nested.asciidoc">edit</a>
</h3>
</div></div></div>
<p>The following parameters are accepted by <code class="literal">nested</code> fields:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="dynamic.html" title="dynamic"><code class="literal">dynamic</code></a>
</span>
</dt>
<dd>
(Optional, string)
Whether or not new <code class="literal">properties</code> should be added dynamically to an existing
nested object.  Accepts <code class="literal">true</code> (default), <code class="literal">false</code> and <code class="literal">strict</code>.
</dd>
<dt>
<span class="term">
<a class="xref" href="properties.html" title="properties"><code class="literal">properties</code></a>
</span>
</dt>
<dd>
(Optional, object)
The fields within the nested object, which can be of any
<a class="xref" href="mapping-types.html" title="Field datatypes">datatype</a>, including <code class="literal">nested</code>. New properties
may be added to an existing nested object.
</dd>
<dt>
<span class="term">
<code class="literal">include_in_parent</code>
</span>
</dt>
<dd>
(Optional, boolean)
If <code class="literal">true</code>, all fields in the nested object are also added to the parent document
as standard (flat) fields. Defaults to <code class="literal">false</code>.
</dd>
<dt>
<span class="term">
<code class="literal">include_in_root</code>
</span>
</dt>
<dd>
(Optional, boolean)
If <code class="literal">true</code>, all fields in the nested object are also added to the root
document as standard (flat) fields. Defaults to <code class="literal">false</code>.
</dd>
</dl>
</div>
<h3>
<a id="_limits_on_nested_mappings_and_objects"></a>Limits on <code class="literal">nested</code> mappings and objects<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/nested.asciidoc">edit</a>
</h3>
<p>As described earlier, each nested object is indexed as a separate Lucene document.
Continuing with the previous example, if we indexed a single document containing 100 <code class="literal">user</code> objects,
then 101 Lucene documents would be created: one for the parent document, and one for each
nested object. Because of the expense associated with <code class="literal">nested</code> mappings, Elasticsearch puts
settings in place to guard against performance problems:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">index.mapping.nested_fields.limit</code>
</span>
</dt>
<dd>
The maximum number of distinct <code class="literal">nested</code> mappings in an index. The <code class="literal">nested</code> type should only be used in special cases, when arrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this setting
limits the number of unique <code class="literal">nested</code> types per index. Default is <code class="literal">50</code>.
</dd>
</dl>
</div>
<p>In the previous example, the <code class="literal">user</code> mapping would count as only 1 towards this limit.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">index.mapping.nested_objects.limit</code>
</span>
</dt>
<dd>
The maximum number of nested JSON objects that a single document can contain across all
<code class="literal">nested</code> types. This limit helps to prevent out of memory errors when a document contains too many nested
objects. Default is <code class="literal">10000</code>.
</dd>
</dl>
</div>
<p>To illustrate how this setting works, consider adding another <code class="literal">nested</code> type called <code class="literal">comments</code>
to the previous example mapping. For each document, the combined number of <code class="literal">user</code> and <code class="literal">comment</code>
objects it contains must be below the limit.</p>
<p>See <a class="xref" href="mapping.html#mapping-limit-settings" title="Settings to prevent mappings explosion">Settings to prevent mappings explosion</a> regarding additional settings for preventing mappings explosion.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="keyword.html">« keyword(关键词)数据类型</a>
</span>
<span class="next">
<a href2="number.html">Numeric datatypes »</a>
</span>
</div>
</div>

                  <!-- end body -->
                        </div>
                        <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                        
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </section>
</div>
<script src="../static/cn.js"></script>
</body>
</html>