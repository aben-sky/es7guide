<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>percolator(渗透器)数据类型 | ElasticSearch 7.7 权威指南中文版</title>
	<meta name="keywords" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <meta name="description" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
	<link rel="stylesheet" type="text/css" href="../static/styles.css" />
	<script>
	var _link = 'percolator.html';
    </script>
</head>
<body>
<div class="main-container">
    <section id="content">
        <div class="content-wrapper">
            <section id="guide" lang="zh_cn">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                            <div style="color:gray; word-break: break-all; font-size:12px;">原英文版地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/percolator.html" rel="nofollow" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/7.7/percolator.html</a>, 原文档版权归 www.elastic.co 所有<br/>本地英文版地址: <a href="../en/percolator.html" rel="nofollow" target="_blank">../en/percolator.html</a></div>
                        <!-- start body -->
                  <div class="page_header">
<strong>重要</strong>: 此版本不会发布额外的bug修复或文档更新。最新信息请参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="nofollow">当前版本文档</a>。
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch 权威指南 [7.7]</a></span>
»
<span class="breadcrumb-link"><a href="mapping.html">映射</a></span>
»
<span class="breadcrumb-link"><a href="mapping-types.html">字段数据类型</a></span>
»
<span class="breadcrumb-node">percolator(渗透器)数据类型</span>
</div>
<div class="navheader">
<span class="prev">
<a href="object.html">« object(对象)数据类型</a>
</span>
<span class="next">
<a href2="range.html">Range datatypes »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title">
<a id="percolator"></a>percolator(渗透器)数据类型
</h2>
</div></div></div>

<p>
<code class="literal">percolator</code>字段类型将一个 json 结构解析成一个本地查询并存储该查询，以便<a class="xref" href="query-dsl-percolate-query.html" title="Percolate query">percolate查询</a>可以使用它来匹配提供的文档。
</p>
<p>
任何包含 json 对象的字段都可以被配置为一个 percolator 字段。

只需配置<code class="literal">percolator</code>字段类型就足以指示 Elasticsearch 将字段视为查询。
</p>
<p>如果下面这个映射将<code class="literal">query</code>字段配置为<code class="literal">percolator</code>字段类型：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my_index
{
    "mappings": {
        "properties": {
            "query": {
                "type": "percolator"
            },
            "field": {
                "type": "text"
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/677.console"></div>
<p>然后你就可以索引一个查询：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my_index/_doc/match_value
{
    "query" : {
        "match" : {
            "field" : "value"
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/678.console"></div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>
percolator 查询中引用的字段必须<span class="strong strong"><strong>已经</strong></span>存在于与用于渗透的索引相关联的映射中。

为了确保这些字段存在，请通过<a class="xref" href="indices-create-index.html" title="创建索引 API" rel="nofollow">创建索引(create index)</a>或<a class="xref" href="indices-put-mapping.html" title="设置映射 API" rel="nofollow">设置映射(put mapping)</a> API添加或更新映射。
</p>
</div>
</div>
<h4>
<a id="_reindexing_your_percolator_queries"></a>重新索引 percolator 查询
</h4>
<p>有时需要重新索引 percolator 查询来从新版本中对<code class="literal">percolator</code>字段类型的改进中获益。</p>
<p>
重新索引 percolator 查询可以通过使用 <a class="xref" href="docs-reindex.html" title="Reindex API" rel="nofollow">reindex api</a> 来重新索引。

让我们来看看下面的一个带有 percolator 类型字段的索引：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /index
{
  "mappings": {
    "properties": {
      "query" : {
        "type" : "percolator"
      },
      "body" : {
        "type": "text"
      }
    }
  }
}

POST /_aliases
{
  "actions": [
    {
      "add": {
        "index": "index",
        "alias": "queries" <a id="CO310-1"></a><i class="conum" data-value="1"></i>
      }
    }
  ]
}

PUT /queries/_doc/1?refresh
{
  "query" : {
    "match" : {
      "body" : "quick brown fox"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/679.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO310-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>总是建议为索引定义一个别名，这样在重新索引的情况下，系统/应用程序不需要改变就知道 percolator 查询现在是在一个不同的索引中。</p>
</td>
</tr>
</table>
</div>
<p>假设要升级到新的 Elasticsearch 主版本，为了让新版本仍然能够读取你的查询，你需要将你的查询重新索引到当前 Elasticsearch 版本的新索引中：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /new_index
{
  "mappings": {
    "properties": {
      "query" : {
        "type" : "percolator"
      },
      "body" : {
        "type": "text"
      }
    }
  }
}

POST /_reindex?refresh
{
  "source": {
    "index": "index"
  },
  "dest": {
    "index": "new_index"
  }
}

POST /_aliases
{
  "actions": [ <a id="CO311-1"></a><i class="conum" data-value="1"></i>
    {
      "remove": {
        "index" : "index",
        "alias": "queries"
      }
    },
    {
      "add": {
        "index": "new_index",
        "alias": "queries"
      }
    }
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/680.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO311-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>如果有一个别名，不要忘记将它指向新的索引。</p>
</td>
</tr>
</table>
</div>
<p>通过<code class="literal">queries</code>别名执行<code class="literal">percolate</code>查询：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /queries/_search
{
  "query": {
    "percolate" : {
      "field" : "query",
      "document" : {
        "body" : "fox jumps over the lazy dog"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/681.console"></div>
<p>现在从新索引中返回了匹配的项：</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 3,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.13076457,
    "hits": [
      {
        "_index": "new_index", <a id="CO312-1"></a><i class="conum" data-value="1"></i>
        "_type": "_doc",
        "_id": "1",
        "_score": 0.13076457,
        "_source": {
          "query": {
            "match": {
              "body": "quick brown fox"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0]
        }
      }
    ]
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO312-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>percolator 查询的命中现在呈现在新的索引中。</p>
</td>
</tr>
</table>
</div>
<h4>
<a id="_optimizing_query_time_text_analysis"></a>优化查询时的文本分析
</h4>
<p>
当 percolator 验证 percolator 候选匹配时，它将进行解析，执行查询时文本分析，并在被渗透的文档上实际运行 percolator 查询。

每次执行<code class="literal">percolate</code>查询时，都会对每个候选匹配进行这样的操作。

如果查询时的文本分析是查询解析中相对昂贵的部分，那么文本分析可能成为渗透时花费时间的主要因素。

当 percolator 最终验证了许多候选 percolator 查询匹配时，这种查询解析开销会变得很明显。
</p>
<p>
为了避免在渗透时进行最昂贵的文本分析，可以选择在索引 percolator 查询时进行高昂的文本分析。

这个 requires 使用两个不同的分析器。

第一个分析器实际上执行需要执行的文本分析(代价高的部分)。

第二个分析器(通常是“空格”)只是拆分第一个分析器生成的词元(token)。

然后，在索引 percolator 查询之前，应该使用 analyze api 通过更昂贵的分析器来分析查询文本。

analyze api的结果，即词元(token)，应该用来替换 percolator 查询中的原始查询文本。

现在应该配置查询以覆盖映射中的分析器，并且只覆盖第二个分析器，这一点很重要。

大多数基于文本的查询支持一个<code class="literal">analyzer</code>选项(<code class="literal">match</code>、<code class="literal">query_string</code>、<code class="literal">simple_query_string</code>)。

使用这种方法，昂贵的文本分析只需要执行一次，而不是多次。
</p>
<p>让我们通过一个简单的例子来演示这个工作流程。</p>
<p>假设我们想要索引下面这个 percolator 查询：</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "query" : {
    "match" : {
      "body" : {
        "query" : "missing bicycles"
      }
    }
  }
}</pre>
</div>
<p>使用这些设置和映射：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /test_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_analyzer" : {
          "tokenizer": "standard",
          "filter" : ["lowercase", "porter_stem"]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "query" : {
        "type": "percolator"
      },
      "body" : {
        "type": "text",
        "analyzer": "my_analyzer" <a id="CO313-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/682.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO313-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>出于这个例子的目的，这个分析器被认为是昂贵的。</p>
</td>
</tr>
</table>
</div>
<p>首先，我们需要使用 analyze api 在编制索引之前执行文本分析：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /test_index/_analyze
{
  "analyzer" : "my_analyzer",
  "text" : "missing bicycles"
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/683.console"></div>
<p>这会导致以下响应：</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "tokens": [
    {
      "token": "miss",
      "start_offset": 0,
      "end_offset": 7,
      "type": "&lt;ALPHANUM&gt;",
      "position": 0
    },
    {
      "token": "bicycl",
      "start_offset": 8,
      "end_offset": 16,
      "type": "&lt;ALPHANUM&gt;",
      "position": 1
    }
  ]
}</pre>
</div>
<p>所有词元(token)都需要以返回的顺序去替换 percolator 查询中的查询文本：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /test_index/_doc/1?refresh
{
  "query" : {
    "match" : {
      "body" : {
        "query" : "miss bicycl",
        "analyzer" : "whitespace" <a id="CO314-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/684.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO314-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>
在这里选择一个 空格(<code class="literal">whitespace</code>)分析器 是很重要的，否则将使用映射中定义的分析器，而这就失去了使用这个工作流的意义。

请注意，<code class="literal">whitespace</code>是一个内置的分析器，如果需要使用不同的分析器，需要先在索引的设置中进行配置。
</p>
</td>
</tr>
</table>
</div>
<p>The analyze api prior to the indexing the percolator flow should be done for each percolator query.</p>
<p>At percolate time nothing changes and the <code class="literal">percolate</code> query can be defined normally:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /test_index/_search
{
  "query": {
    "percolate" : {
      "field" : "query",
      "document" : {
        "body" : "Bycicles are missing"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/685.console"></div>
<p>This results in a response like this:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 6,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.13076457,
    "hits": [
      {
        "_index": "test_index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.13076457,
        "_source": {
          "query": {
            "match": {
              "body": {
                "query": "miss bicycl",
                "analyzer": "whitespace"
              }
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0]
        }
      }
    ]
  }
}</pre>
</div>
<h4>
<a id="_optimizing_wildcard_queries"></a>Optimizing wildcard queries.<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/percolator.asciidoc">edit</a>
</h4>
<p>Wildcard queries are  more expensive than other queries for the percolator,
especially if the wildcard expressions are large.</p>
<p>In the case of <code class="literal">wildcard</code> queries with prefix wildcard expressions or just the <code class="literal">prefix</code> query,
the <code class="literal">edge_ngram</code> token filter can be used to replace these queries with regular <code class="literal">term</code>
query on a field where the <code class="literal">edge_ngram</code> token filter is configured.</p>
<p>Creating an index with custom analysis settings:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my_queries1
{
  "settings": {
    "analysis": {
      "analyzer": {
        "wildcard_prefix": { <a id="CO315-1"></a><i class="conum" data-value="1"></i>
          "type": "custom",
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "wildcard_edge_ngram"
          ]
        }
      },
      "filter": {
        "wildcard_edge_ngram": { <a id="CO315-2"></a><i class="conum" data-value="2"></i>
          "type": "edge_ngram",
          "min_gram": 1,
          "max_gram": 32
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "query": {
        "type": "percolator"
      },
      "my_field": {
        "type": "text",
        "fields": {
          "prefix": { <a id="CO315-3"></a><i class="conum" data-value="3"></i>
            "type": "text",
            "analyzer": "wildcard_prefix",
            "search_analyzer": "standard"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/686.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO315-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The analyzer that generates the prefix tokens to be used at index time only.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO315-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Increase the <code class="literal">min_gram</code> and decrease <code class="literal">max_gram</code> settings based on your prefix search needs.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO315-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>This multifield should be used to do the prefix search
with a <code class="literal">term</code> or <code class="literal">match</code> query instead of a <code class="literal">prefix</code> or <code class="literal">wildcard</code> query.</p>
</td>
</tr>
</table>
</div>
<p>Then instead of indexing the following query:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "query": {
    "wildcard": {
      "my_field": "abc*"
    }
  }
}</pre>
</div>
<p>this query below should be indexed:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my_queries1/_doc/1?refresh
{
  "query": {
    "term": {
      "my_field.prefix": "abc"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/687.console"></div>
<p>This way can handle the second query more efficiently than the first query.</p>
<p>The following search request will match with the previously indexed
percolator query:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my_queries1/_search
{
  "query": {
    "percolate": {
      "field": "query",
      "document": {
        "my_field": "abcd"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/688.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 6,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.18864399,
    "hits": [
      {
        "_index": "my_queries1",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.18864399,
        "_source": {
          "query": {
            "term": {
              "my_field.prefix": "abc"
            }
          }
        },
        "fields": {
          "_percolator_document_slot": [
            0
          ]
        }
      }
    ]
  }
}</pre>
</div>
<p>The same technique can also be used to speed up suffix
wildcard searches. By using the <code class="literal">reverse</code> token filter
before the <code class="literal">edge_ngram</code> token filter.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my_queries2
{
  "settings": {
    "analysis": {
      "analyzer": {
        "wildcard_suffix": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "reverse",
            "wildcard_edge_ngram"
          ]
        },
        "wildcard_suffix_search_time": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "reverse"
          ]
        }
      },
      "filter": {
        "wildcard_edge_ngram": {
          "type": "edge_ngram",
          "min_gram": 1,
          "max_gram": 32
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "query": {
        "type": "percolator"
      },
      "my_field": {
        "type": "text",
        "fields": {
          "suffix": {
            "type": "text",
            "analyzer": "wildcard_suffix",
            "search_analyzer": "wildcard_suffix_search_time" <a id="CO316-1"></a><i class="conum" data-value="1"></i>
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/689.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO316-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>A custom analyzer is needed at search time too, because otherwise
the query terms are not being reversed and would otherwise not match
with the reserved suffix tokens.</p>
</td>
</tr>
</table>
</div>
<p>Then instead of indexing the following query:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "query": {
    "wildcard": {
      "my_field": "*xyz"
    }
  }
}</pre>
</div>
<p>the following query below should be indexed:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my_queries2/_doc/2?refresh
{
  "query": {
    "match": { <a id="CO317-1"></a><i class="conum" data-value="1"></i>
      "my_field.suffix": "xyz"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/690.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO317-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">match</code> query should be used instead of the <code class="literal">term</code> query,
because text analysis needs to reverse the query terms.</p>
</td>
</tr>
</table>
</div>
<p>The following search request will match with the previously indexed
percolator query:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my_queries2/_search
{
  "query": {
    "percolate": {
      "field": "query",
      "document": {
        "my_field": "wxyz"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/691.console"></div>
<h4>
<a id="_dedicated_percolator_index"></a>Dedicated Percolator Index<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/percolator.asciidoc">edit</a>
</h4>
<p>Percolate queries can be added to any index. Instead of adding percolate queries to the index the data resides in,
these queries can also be added to a dedicated index. The advantage of this is that this dedicated percolator index
can have its own index settings (For example the number of primary and replica shards). If you choose to have a dedicated
percolate index, you need to make sure that the mappings from the normal index are also available on the percolate index.
Otherwise percolate queries can be parsed incorrectly.</p>
<h4>
<a id="_forcing_unmapped_fields_to_be_handled_as_strings"></a>Forcing Unmapped Fields to be Handled as Strings<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/percolator.asciidoc">edit</a>
</h4>
<p>In certain cases it is unknown what kind of percolator queries do get registered, and if no field mapping exists for fields
that are referred by percolator queries then adding a percolator query fails. This means the mapping needs to be updated
to have the field with the appropriate settings, and then the percolator query can be added. But sometimes it is sufficient
if all unmapped fields are handled as if these were default text fields. In those cases one can configure the
<code class="literal">index.percolator.map_unmapped_fields_as_text</code> setting to <code class="literal">true</code> (default to <code class="literal">false</code>) and then if a field referred in
a percolator query does not exist, it will be handled as a default text field so that adding the percolator query doesn’t
fail.</p>
<h4>
<a id="_limitations_8"></a>Limitations<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/percolator.asciidoc">edit</a>
</h4>
<h5>
<a id="parent-child"></a>Parent/child<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/percolator.asciidoc">edit</a>
</h5>
<p>Because the <code class="literal">percolate</code> query is processing one document at a time, it doesn’t support queries and filters that run
against child documents such as <code class="literal">has_child</code> and <code class="literal">has_parent</code>.</p>
<h5>
<a id="_fetching_queries"></a>Fetching queries<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/percolator.asciidoc">edit</a>
</h5>
<p>There are a number of queries that fetch data via a get call during query parsing. For example the <code class="literal">terms</code> query when
using terms lookup, <code class="literal">template</code> query when using indexed scripts and <code class="literal">geo_shape</code> when using pre-indexed shapes. When these
queries are indexed by the <code class="literal">percolator</code> field type then the get call is executed once. So each time the <code class="literal">percolator</code>
query evaluates these queries, the fetches terms, shapes etc. as the were upon index time will be used. Important to note
is that fetching of terms that these queries do, happens both each time the percolator query gets indexed on both primary
and replica shards, so the terms that are actually indexed can be different between shard copies, if the source index
changed while indexing.</p>
<h5>
<a id="_script_query"></a>Script query<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/percolator.asciidoc">edit</a>
</h5>
<p>The script inside a <code class="literal">script</code> query can only access doc values fields. The <code class="literal">percolate</code> query indexes the provided document
into an in-memory index. This in-memory index doesn’t support stored fields and because of that the <code class="literal">_source</code> field and
other stored fields are not stored. This is the reason why in the <code class="literal">script</code> query the <code class="literal">_source</code> and other stored fields
aren’t available.</p>
<h5>
<a id="_field_aliases"></a>Field aliases<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/types/percolator.asciidoc">edit</a>
</h5>
<p>Percolator queries that contain <a class="xref" href="alias.html" title="Alias datatype">field aliases</a> may not always behave as expected. In particular, if a
percolator query is registered that contains a field alias, and then that alias is updated in the mappings to refer
to a different field, the stored query will still refer to the original target field. To pick up the change to
the field alias, the percolator query must be explicitly reindexed.</p>
</div>
<div class="navfooter">
<span class="prev">
<a href="object.html">« object(对象)数据类型</a>
</span>
<span class="next">
<a href2="range.html">Range datatypes »</a>
</span>
</div>
</div>

                  <!-- end body -->
                        </div>
                        <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                        
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </section>
</div>
<script src="../static/cn.js"></script>
</body>
</html>