<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>percolate 查询 | ElasticSearch 7.7 权威指南中文版</title>
	<meta name="keywords" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <meta name="description" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
	<link rel="stylesheet" type="text/css" href="../static/styles.css" />
	<script>
	var _link = 'query-dsl-percolate-query.html';
    </script>
</head>
<body>
<div class="main-container">
    <section id="content">
        <div class="content-wrapper">
            <section id="guide" lang="zh_cn">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                            <div style="color:gray; word-break: break-all; font-size:12px;">原英文版地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/query-dsl-percolate-query.html" rel="nofollow" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/7.7/query-dsl-percolate-query.html</a>, 原文档版权归 www.elastic.co 所有<br/>本地英文版地址: <a href="../en/query-dsl-percolate-query.html" rel="nofollow" target="_blank">../en/query-dsl-percolate-query.html</a></div>
                        <!-- start body -->
                  <div class="page_header">
<strong>重要</strong>: 此版本不会发布额外的bug修复或文档更新。最新信息请参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="nofollow">当前版本文档</a>。
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch 权威指南 [7.7]</a></span>
»
<span class="breadcrumb-link"><a href="query-dsl.html">查询领域特定语言(Query DSL)</a></span>
»
<span class="breadcrumb-link"><a href="specialized-queries.html">专业的查询</a></span>
»
<span class="breadcrumb-node">percolate 查询</span>
</div>
<div class="navheader">
<span class="prev">
<a href="query-dsl-mlt-query.html">« more_like_this 查询</a>
</span>
<span class="next">
<a href2="_notes_4.html">Notes »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title">
<a id="query-dsl-percolate-query"></a>percolate 查询
</h2>
</div></div></div>

<p>
percolate查询可用于匹配存储在索引中的查询。

<code class="literal">percolate</code> 查询本身包含将用作查询的文档，以匹配存储的查询。
</p>
<h3>
<a id="_sample_usage"></a>使用示例
</h3>
<p>创建一个有2个字段的索引：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my-index
{
    "mappings": {
        "properties": {
             "message": {
                 "type": "text"
             },
             "query": {
                 "type": "percolator"
             }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/238.console"></div>
<p>
<code class="literal">message</code> 字段是用于在将 <code class="literal">percolator</code> 查询中定义的文档编入临时索引之前对其进行预处理的字段。
</p>
<p>
<code class="literal">query</code> 字段用于索引查询文档。

它将保存一个 json 对象，表示一个实际的 Elasticsearch 查询。

字段 <code class="literal">query</code> 已在映射中配置为使用<a class="xref" href="percolator.html" title="Percolator type">percolator字段类型</a>。

这个字段类型理解查询领域专用语言(dsl)，并以这样的方式存储查询，以便以后可以使用它来匹配在 <code class="literal">percolate</code> 查询中定义的文档。
</p>
<p>在 percolator 中注册一个查询<span class="remark">（相当于添加并索引一个id为1的文档）</span>：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my-index/_doc/1?refresh
{
    "query" : {
        "match" : {
            "message" : "bonsai tree"
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/239.console"></div>
<p>将文档与注册的 percolator 查询进行匹配：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field" : "query",
            "document" : {
                "message" : "A new bonsai tree in the office"
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/240.console"></div>
<p>上面这个请求将产生如下响应：</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 13,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.26152915,
    "hits": [
      { <a id="CO50-1"></a><i class="conum" data-value="1"></i>
        "_index": "my-index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.26152915,
        "_source": {
          "query": {
            "match": {
              "message": "bonsai tree"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0] <a id="CO50-2"></a><i class="conum" data-value="2"></i>
        }
      }
    ]
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO50-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>id 为 <code class="literal">1</code> 的 query 与文档匹配。</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO50-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>
字段 <code class="literal">_percolator_document_slot</code> 指示哪个文档与该查询匹配。

在同时渗透(percolating)多个文档时非常有用。
</p>
</td>
</tr>
</table>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>
为了举一个简单的例子，这个文档为 percolate 查询和文档使用一个名为 my-index 的索引。

当只注册了几个 percolate 查询时，这种设置可以很好地工作。

但是，如果使用量较大，建议将查询和文档存储在单独的索引中。

更多细节请参考 <a class="xref" href="query-dsl-percolate-query.html#how-it-works" title="How it Works Under the Hood">它如何在引擎盖下工作的</a>。
</p>
</div>
</div>
<h4>
<a id="_parameters_3"></a>参数
</h4>
<p>渗透(percolating)文档时需要以下参数：</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col>
<col>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">field</code>
</p>
</td>
<td valign="top">
<p>
(必需) 保存索引查询的 <code class="literal">percolator</code> 类型的字段。
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">name</code>
</p>
</td>
<td valign="top">
<p>
(可选) 在指定了多个 <code class="literal">percolate</code> 查询的情况下，用于 <code class="literal">_percolator_document_slot</code> 字段的后缀。
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">document</code>
</p>
</td>
<td valign="top">
<p>
被渗透的文档源。
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">documents</code>
</p>
</td>
<td valign="top">
<p>
类似于 <code class="literal">document</code> 参数，但是可以通过 json 数组接受多个文档。
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">document_type</code>
</p>
</td>
<td valign="top">
<p>
被渗透的文档的类型(type)/映射(mapping)。此参数已被废弃，将在 Elasticsearch 8.0 中移除。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>
也可以从已经存储的文档中检索源，而不是指定要渗透的文档源。

然后，<code class="literal">percolate</code> 查询将在内部执行一个 get 请求来获取文档。
</p>
<p>
在这种情况下，<code class="literal">document</code> 参数可以用以下参数替换：
</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col>
<col>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">index</code>
</p>
</td>
<td valign="top">
<p>
(必需) 文档所在的索引。
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">type</code>
</p>
</td>
<td valign="top">
<p>
要获取的文档的类型。此参数已被废弃，将在 Elasticsearch 8.0 中移除。
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">id</code>
</p>
</td>
<td valign="top">
<p>
(必需) 要获取的文档的 id。
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">routing</code>
</p>
</td>
<td valign="top">
<p>
(可选) 用于获取要渗透(percolate)的文档的路由。
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">preference</code>
</p>
</td>
<td valign="top">
<p>
(可选) 用于获取要渗透的文档的首选项。
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">version</code>
</p>
</td>
<td valign="top">
<p>
(可选) 预期要获取的文档的版本。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<h4>
<a id="_percolating_in_a_filter_context"></a>在过滤上下文中渗透（percolating in a filter context）
</h4>
<p>
如果你对相关性评分不感兴趣，可以通过将 <code class="literal">percolator</code> 查询包裹在 <code class="literal">bool</code> 查询的 filter 子句或 <code class="literal">constant_score</code> 查询中来获得更好的性能：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my-index/_search
{
    "query" : {
        "constant_score": {
            "filter": {
                "percolate" : {
                    "field" : "query",
                    "document" : {
                        "message" : "A new bonsai tree in the office"
                    }
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/241.console"></div>
<p>
在索引时，从渗透器(percolator) query 中提取 词项(term)，渗透器通常可以通过查看这些提取的词项来确定查询是否匹配。

然而，计算得分需要对每个匹配的查询进行反序列化，并在渗透后的文档上运行，这是一个成本很高的操作。

因此，如果不需要计算得分，则 <code class="literal">percolate</code> 查询应该包裹在一个 <code class="literal">constant_score</code> 查询或 <code class="literal">bool</code> 查询的 filter 子句中。
</p>
<p>
请注意，查询缓存永远不会缓存 <code class="literal">percolate</code> 查询。
</p>
<h4>
<a id="_percolating_multiple_documents"></a>渗透多个文档 (percolating multiple documents)
</h4>
<p>
<code class="literal">percolate</code> 查询可以用索引过的渗透查询同时匹配多个文档。

在单个请求中渗透多个文档可以提高性能，因为查询只需要解析和匹配一次，而不是多次。
</p>
<p>
同时渗透多个文档时，每个匹配的渗透器查询返回的 <code class="literal">_percolator_document_slot</code> 字段非常重要。

它指示哪些文档与特定的渗透器查询相匹配。

这些数字与 <code class="literal">percolate</code> 查询中指定的 <code class="literal">documents</code> 数组中的槽相关。
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field" : "query",
            "documents" : [ <a id="CO51-1"></a><i class="conum" data-value="1"></i>
                {
                    "message" : "bonsai tree"
                },
                {
                    "message" : "new tree"
                },
                {
                    "message" : "the office"
                },
                {
                    "message" : "office tree"
                }
            ]
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/242.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO51-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">documents</code> 数组包含4个将被同时渗透的文档。</p>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 13,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.7093853,
    "hits": [
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.7093853,
        "_source": {
          "query": {
            "match": {
              "message": "bonsai tree"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0, 1, 3] <a id="CO52-1"></a><i class="conum" data-value="1"></i>
        }
      }
    ]
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO52-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">_percolator_document_slot</code> 表示在 <code class="literal">percolate</code> 查询中指定的第一个、第二个和最后一个文档与该查询匹配。</p>
</td>
</tr>
</table>
</div>
<h4>
<a id="_percolating_an_existing_document"></a>渗透一个已存在的文档 (percolating an existing document)
</h4>
<p>
为了渗透新索引的文档，可以使用 <code class="literal">percolate</code> 查询。

基于来自索引请求的响应，可以使用 <code class="literal">_id</code> 和其他元信息来立即渗透新添加的文档。
</p>
<h5>
<a id="_example"></a>示例
</h5>
<p>基于前面的例子。</p>
<p>索引要渗透的文档：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my-index/_doc/2
{
  "message" : "A new bonsai tree in the office"
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/243.console"></div>
<p>索引响应：</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "_index": "my-index",
  "_type": "_doc",
  "_id": "2",
  "_version": 1,
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "result": "created",
  "_seq_no" : 1,
  "_primary_term" : 1
}</pre>
</div>
<p>渗透现有文档，使用索引响应作为基础来构建新的搜索请求：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field": "query",
            "index" : "my-index",
            "id" : "2",
            "version" : 1 <a id="CO53-1"></a><i class="conum" data-value="1"></i>
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/244.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO53-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>
version 是可选的，但在某些情况下很有用。

我们可以确保我们正在尝试渗透我们刚刚索引的文档。

在我们建立索引后，可能会进行更改，如果是这种情况，搜索请求将会失败，并抛出版本的冲突错误。
</p>
</td>
</tr>
</table>
</div>
<p>返回的搜索响应与前面的示例相同。

</p>
<h4>
<a id="_percolate_query_and_highlighting"></a>渗透查询以及高亮 (percolate query and highlighting)
</h4>
<p>The <code class="literal">percolate</code> query is handled in a special way when it comes to highlighting. The queries hits are used
to highlight the document that is provided in the <code class="literal">percolate</code> query. Whereas with regular highlighting the query in
the search request is used to highlight the hits.</p>
<h5>
<a id="_example_2"></a>Example<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/query-dsl/percolate-query.asciidoc">edit</a>
</h5>
<p>This example is based on the mapping of the first example.</p>
<p>Save a query:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my-index/_doc/3?refresh
{
    "query" : {
        "match" : {
            "message" : "brown fox"
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/245.console"></div>
<p>Save another query:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my-index/_doc/4?refresh
{
    "query" : {
        "match" : {
            "message" : "lazy dog"
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/246.console"></div>
<p>Execute a search request with the <code class="literal">percolate</code> query and highlighting enabled:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field": "query",
            "document" : {
                "message" : "The quick brown fox jumps over the lazy dog"
            }
        }
    },
    "highlight": {
      "fields": {
        "message": {}
      }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/247.console"></div>
<p>This will yield the following response.</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 7,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 2,
        "relation": "eq"
    },
    "max_score": 0.26152915,
    "hits": [
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "3",
        "_score": 0.26152915,
        "_source": {
          "query": {
            "match": {
              "message": "brown fox"
            }
          }
        },
        "highlight": {
          "message": [
            "The quick &lt;em&gt;brown&lt;/em&gt; &lt;em&gt;fox&lt;/em&gt; jumps over the lazy dog" <a id="CO54-1"></a><i class="conum" data-value="1"></i>
          ]
        },
        "fields" : {
          "_percolator_document_slot" : [0]
        }
      },
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "4",
        "_score": 0.26152915,
        "_source": {
          "query": {
            "match": {
              "message": "lazy dog"
            }
          }
        },
        "highlight": {
          "message": [
            "The quick brown fox jumps over the &lt;em&gt;lazy&lt;/em&gt; &lt;em&gt;dog&lt;/em&gt;" <a id="CO54-2"></a><i class="conum" data-value="1"></i>
          ]
        },
        "fields" : {
          "_percolator_document_slot" : [0]
        }
      }
    ]
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO54-1"><i class="conum" data-value="1"></i></a><a href="#CO54-2"></a></p>
</td>
<td align="left" valign="top">
<p>The terms from each query have been highlighted in the document.</p>
</td>
</tr>
</table>
</div>
<p>Instead of the query in the search request highlighting the percolator hits, the percolator queries are highlighting
the document defined in the <code class="literal">percolate</code> query.</p>
<p>When percolating multiple documents at the same time like the request below then the highlight response is different:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my-index/_search
{
    "query" : {
        "percolate" : {
            "field": "query",
            "documents" : [
                {
                    "message" : "bonsai tree"
                },
                {
                    "message" : "new tree"
                },
                {
                    "message" : "the office"
                },
                {
                    "message" : "office tree"
                }
            ]
        }
    },
    "highlight": {
      "fields": {
        "message": {}
      }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/248.console"></div>
<p>The slightly different response:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 13,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.7093853,
    "hits": [
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.7093853,
        "_source": {
          "query": {
            "match": {
              "message": "bonsai tree"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0, 1, 3]
        },
        "highlight" : { <a id="CO55-1"></a><i class="conum" data-value="1"></i>
          "0_message" : [
              "&lt;em&gt;bonsai&lt;/em&gt; &lt;em&gt;tree&lt;/em&gt;"
          ],
          "3_message" : [
              "office &lt;em&gt;tree&lt;/em&gt;"
          ],
          "1_message" : [
              "new &lt;em&gt;tree&lt;/em&gt;"
          ]
        }
      }
    ]
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO55-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The highlight fields have been prefixed with the document slot they belong to,
in order to know which highlight field belongs to what document.</p>
</td>
</tr>
</table>
</div>
<h4>
<a id="_specifying_multiple_percolate_queries"></a>Specifying multiple percolate queries<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/query-dsl/percolate-query.asciidoc">edit</a>
</h4>
<p>It is possible to specify multiple <code class="literal">percolate</code> queries in a single search request:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my-index/_search
{
    "query" : {
        "bool" : {
            "should" : [
                {
                    "percolate" : {
                        "field" : "query",
                        "document" : {
                            "message" : "bonsai tree"
                        },
                        "name": "query1" <a id="CO56-1"></a><i class="conum" data-value="1"></i>
                    }
                },
                {
                    "percolate" : {
                        "field" : "query",
                        "document" : {
                            "message" : "tulip flower"
                        },
                        "name": "query2" <a id="CO56-2"></a><i class="conum" data-value="1"></i>
                    }
                }
            ]
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/249.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO56-1"><i class="conum" data-value="1"></i></a><a href="#CO56-2"></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">name</code> parameter will be used to identify which percolator document slots belong to what <code class="literal">percolate</code> query.</p>
</td>
</tr>
</table>
</div>
<p>The <code class="literal">_percolator_document_slot</code> field name will be suffixed with what is specified in the <code class="literal">_name</code> parameter.
If that isn’t specified then the <code class="literal">field</code> parameter will be used, which in this case will result in ambiguity.</p>
<p>The above search request returns a response similar to this:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 13,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.26152915,
    "hits": [
      {
        "_index": "my-index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.26152915,
        "_source": {
          "query": {
            "match": {
              "message": "bonsai tree"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot_query1" : [0] <a id="CO57-1"></a><i class="conum" data-value="1"></i>
        }
      }
    ]
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO57-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">_percolator_document_slot_query1</code> percolator slot field indicates that these matched slots are from the <code class="literal">percolate</code>
query with <code class="literal">_name</code> parameter set to <code class="literal">query1</code>.</p>
</td>
</tr>
</table>
</div>
<h4>
<a id="how-it-works"></a>How it Works Under the Hood<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/query-dsl/percolate-query.asciidoc">edit</a>
</h4>
<p>When indexing a document into an index that has the <a class="xref" href="percolator.html" title="Percolator type">percolator field type</a> mapping configured, the query
part of the document gets parsed into a Lucene query and is stored into the Lucene index. A binary representation
of the query gets stored, but also the query’s terms are analyzed and stored into an indexed field.</p>
<p>At search time, the document specified in the request gets parsed into a Lucene document and is stored in a in-memory
temporary Lucene index. This in-memory index can just hold this one document and it is optimized for that. After this
a special query is built based on the terms in the in-memory index that select candidate percolator queries based on
their indexed query terms. These queries are then evaluated by the in-memory index if they actually match.</p>
<p>The selecting of candidate percolator queries matches is an important performance optimization during the execution
of the <code class="literal">percolate</code> query as it can significantly reduce the number of candidate matches the in-memory index needs to
evaluate. The reason the <code class="literal">percolate</code> query can do this is because during indexing of the percolator queries the query
terms are being extracted and indexed with the percolator query. Unfortunately the percolator cannot extract terms from
all queries (for example the <code class="literal">wildcard</code> or <code class="literal">geo_shape</code> query) and as a result of that in certain cases the percolator
can’t do the selecting optimization (for example if an unsupported query is defined in a required clause of a boolean query
or the unsupported query is the only query in the percolator document).  These queries are marked by the percolator and
can be found by running the following search:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "term" : {
      "query.extraction_result" : "failed"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/250.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The above example assumes that there is a <code class="literal">query</code> field of type
<code class="literal">percolator</code> in the mappings.</p>
</div>
</div>
<p>Given the design of percolation, it often makes sense to use separate indices for the percolate queries and documents
being percolated, as opposed to a single index as we do in examples. There are a few benefits to this approach:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Because percolate queries contain a different set of fields from the percolated documents, using two separate indices
allows for fields to be stored in a denser, more efficient way.
</li>
<li class="listitem">
Percolate queries do not scale in the same way as other queries, so percolation performance may benefit from using
a different index configuration, like the number of primary shards.
</li>
</ul>
</div>
</div>
<div class="navfooter">
<span class="prev">
<a href="query-dsl-mlt-query.html">« more_like_this 查询</a>
</span>
<span class="next">
<a href2="_notes_4.html">Notes »</a>
</span>
</div>
</div>

                  <!-- end body -->
                        </div>
                        <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                        
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </section>
</div>
<script src="../static/cn.js"></script>
</body>
</html>