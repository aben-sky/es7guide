<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>删除的映射类型 | ElasticSearch 7.7 权威指南中文版</title>
	<meta name="keywords" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <meta name="description" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
	<link rel="stylesheet" type="text/css" href="../static/styles.css" />
	<script>
	var _link = 'removal-of-types.html';
    </script>
</head>
<body>
<div class="main-container">
    <section id="content">
        <div class="content-wrapper">
            <section id="guide" lang="zh_cn">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                            <div style="color:gray; word-break: break-all; font-size:12px;">原英文版地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/removal-of-types.html" rel="nofollow" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/7.7/removal-of-types.html</a>, 原文档版权归 www.elastic.co 所有<br/>本地英文版地址: <a href="../en/removal-of-types.html" rel="nofollow" target="_blank">../en/removal-of-types.html</a></div>
                        <!-- start body -->
                  <div class="page_header">
<strong>重要</strong>: 此版本不会发布额外的bug修复或文档更新。最新信息请参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="nofollow">当前版本文档</a>。
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch 权威指南 [7.7]</a></span>
»
<span class="breadcrumb-link"><a href="mapping.html">映射</a></span>
»
<span class="breadcrumb-node">删除的映射类型</span>
</div>
<div class="navheader">
<span class="prev">
<a href="mapping.html">« 映射</a>
</span>
<span class="next">
<a href2="mapping-types.html">Field datatypes »</a>
</span>
</div>
<div class="chapter">
<div class="titlepage"><div><div>
<h2 class="title">
<a id="removal-of-types"></a>删除的映射类型
</h2>
</div></div></div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>
在 Elasticsearch 7.0.0 或更高版本中创建的索引不再接受<code class="literal">_default_</code>映射。

在 6.x 中创建的索引将继续像以前一样在 Elasticsearch 6.x 中运行。

在7.0的API中 type 被废弃，对索引创建、设置映射、获取映射、设置模板、获取模板及获取字段映射API进行了重大更改。
</p>
</div>
</div>
<h3>
<a id="_what_are_mapping_types"></a>映射类型是什么?
</h3>
<p>
自从Elasticsearch第一次发布以来，每个文档都存储在一个索引中，并被分配一个映射类型。

映射类型用于表示被索引的文档或实体的类型，例如，一个名为<code class="literal">twitter</code>的索引可能有一个<code class="literal">user</code>类型和一个<code class="literal">tweet</code>类型。
</p>
<p>每种映射类型都有自己的字段，因此用户类型可能有一个<code class="literal">full_name</code>字段、一个<code class="literal">user_name</code>字段和一个<code class="literal">email</code>字段；而<code class="literal">tweet</code>类型可能有一个<code class="literal">content</code>字段、一个<code class="literal">tweeted_at</code>字段，和用户类型一样，还有一个<code class="literal">user_name</code>字段。</p>
<p>每个文档都有一个包含类型名称的<code class="literal">_type</code>元字段，通过在URL中指定类型名称，可以将搜索限制到一个或多个类型：</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">GET twitter/user,tweet/_search
{
  "query": {
    "match": {
      "user_name": "kimchy"
    }
  }
}</pre>
</div>
<p>字段<code class="literal">_type</code>与文档的<code class="literal">_id</code>组合起来生成字段<code class="literal">_uid</code>，因此具有相同<code class="literal">_id</code>的不同类型的文档可以存在于一个索引中。</p>
<p>映射类型还用于建立文档之间的<a class="xref" href="parent-join.html" title="Join datatype">父-子关系</a>，因此<code class="literal">question</code>类型的文档可以是<code class="literal">answer</code>类型文档的父文档。</p>
<h3>
<a id="_why_are_mapping_types_being_removed"></a>为什么要删除映射类型？
</h3>
<p>最初，我们谈到“索引(index)”类似于SQL数据库中的“数据库(database)”，而“类型(type)”相当于“表(tbale)”。</p>
<p>
这是一个糟糕的类比，导致了错误的假设。

在SQL数据库中，表是相互独立的。

一个表中的列与另一个表中同名的列没有关系。

对于映射类型中的字段，情况却并非如此。
</p>
<p>
在一个 Elasticsearch 索引中，不同映射类型中具有相同名称的字段在内部由相同的 Lucene 字段支持。

换句话说，使用上面的例子，<code class="literal">user</code>类型中的字段<code class="literal">user_name</code>与<code class="literal">tweet</code>类型中的字段<code class="literal">user_name</code>存储在完全相同的字段中，并且两个<code class="literal">user_name</code>字段在两种类型中必须具有相同的映射(定义)。
</p>
<p>例如，当你希望在同一个索引中，字段<code class="literal">deleted</code>在一种类型下是<code class="literal">date</code>(类型的)字段，而在另一种类型下是<code class="literal">boolean</code>(类型的)字段时，这可能会导致失败。</p>
<p>最重要的是，在同一个索引中存储很少或没有共同字段的不同实体会导致数据稀疏，并干扰 Lucene 有效压缩文档的能力。</p>
<p>出于这些原因，我们决定从Elasticsearch中删除映射类型的概念。</p>
<h3>
<a id="_alternatives_to_mapping_types"></a>映射类型的替代方法
</h3>
<h4>
<a id="_index_per_document_type"></a>一个文档类型一个索引
</h4>
<p>
第一种方法是为每种文档类型建立一个索引。

可以将 tweets 存储在索引<code class="literal">tweets</code>中，将 users 存储在索引<code class="literal">user</code>中，而不是将 tweets 和 users 存储在同一个索引<code class="literal">twitter</code>中。

索引彼此完全独立，因此索引之间不会有字段类型冲突。
</p>
<p>这种方法有两个有点：</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
数据更可能是密集的，因此可以受益于Lucene中使用的压缩技术。
</li>
<li class="listitem">
在全文搜索中用于评分的词项统计更有可能是准确的，因为同一索引中的所有文档都代表一个实体。
</li>
</ul>
</div>
<p>每个索引可以根据其包含的文档数量进行适当调整：你可以为索引<code class="literal">users</code>使用较少数量的主分片，而为索引<code class="literal">tweets</code>使用较多数量的主分片。</p>
<h4>
<a id="_custom_type_field"></a>自定义类型字段
</h4>
<p>
当然，一个集群中可存在的主分片的数量是有限制的，所以你可能不希望为了几千个文档的集合而浪费整个分片。

在这种情况下，你可以实现自己的自定义<code class="literal">type</code>字段，其工作方式与老的<code class="literal">_type</code>类似。
</p>
<p>让我们以上面的<code class="literal">user</code>/<code class="literal">tweet</code>为例。最初，工作流应该是这样的：</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">PUT twitter
{
  "mappings": {
    "user": {
      "properties": {
        "name": { "type": "text" },
        "user_name": { "type": "keyword" },
        "email": { "type": "keyword" }
      }
    },
    "tweet": {
      "properties": {
        "content": { "type": "text" },
        "user_name": { "type": "keyword" },
        "tweeted_at": { "type": "date" }
      }
    }
  }
}

PUT twitter/user/kimchy
{
  "name": "Shay Banon",
  "user_name": "kimchy",
  "email": "shay@kimchy.com"
}

PUT twitter/tweet/1
{
  "user_name": "kimchy",
  "tweeted_at": "2017-10-24T09:00:00Z",
  "content": "Types are going away"
}

GET twitter/tweet/_search
{
  "query": {
    "match": {
      "user_name": "kimchy"
    }
  }
}</pre>
</div>
<p>可以通过添加自定义的<code class="literal">type</code>字段来实现相同的目的，如下所示：</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">PUT twitter
{
  "mappings": {
    "_doc": {
      "properties": {
        "type": { "type": "keyword" }, <a id="CO284-1"></a><i class="conum" data-value="1"></i>
        "name": { "type": "text" },
        "user_name": { "type": "keyword" },
        "email": { "type": "keyword" },
        "content": { "type": "text" },
        "tweeted_at": { "type": "date" }
      }
    }
  }
}

PUT twitter/_doc/user-kimchy
{
  "type": "user", <a id="CO284-2"></a><i class="conum" data-value="1"></i>
  "name": "Shay Banon",
  "user_name": "kimchy",
  "email": "shay@kimchy.com"
}

PUT twitter/_doc/tweet-1
{
  "type": "tweet", <a id="CO284-3"></a><i class="conum" data-value="1"></i>
  "user_name": "kimchy",
  "tweeted_at": "2017-10-24T09:00:00Z",
  "content": "Types are going away"
}

GET twitter/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "user_name": "kimchy"
        }
      },
      "filter": {
        "match": {
          "type": "tweet" <a id="CO284-4"></a><i class="conum" data-value="1"></i>
        }
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO284-1"><i class="conum" data-value="1"></i></a><a href="#CO284-2"></a><a href="#CO284-3"></a><a href="#CO284-4"></a></p>
</td>
<td align="left" valign="top">
<p>显式的<code class="literal">type</code>字段取代了显式的<code class="literal">_type</code>字段。</p>
</td>
</tr>
</table>
</div>
<h4>
<a id="parent-child-mapping-types"></a>没有映射类型的父/子
</h4>
<p>
以前，父-子关系是通过将一个映射类型作为父类型，将一个或多个其他映射类型作为子类型来表示的。

没有类型，我们就不能再使用这种语法。

父子特性将继续像以前一样工作，只是表达文档之间关系的方式已经更改为使用新的<a class="xref" href="parent-join.html" title="join 数据类型" rel="nofollow"><code class="literal">join</code>字段</a>。
</p>
<h3>
<a id="_schedule_for_removal_of_mapping_types"></a>映射类型的删除计划
</h3>
<p>对于我们的用户来说，这是一个很大的变化，所以我们尽量让它不那么痛苦。变更将按如下方式展开：</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Elasticsearch 5.6.0
</span>
</dt>
<dd>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
在索引上设置<code class="literal">index.mapping.single_type: true</code>将启用每个索引一个类型的行为，这将在 6.0 中强制实施。
</li>
<li class="listitem">
父-子关系的<a class="xref" href="parent-join.html" title="join 数据类型" rel="nofollow"><code class="literal">join</code>字段</a>替换在 5.6 中创建的索引上可用。
</li>
</ul>
</div>
</dd>
<dt>
<span class="term">
Elasticsearch 6.x
</span>
</dt>
<dd>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
在 5.x 中创建的索引将像在 5.x 中一样继续在 6.x 中运行。
</li>
<li class="listitem">
在 6.x 中创建的索引只允许一个索引一个类型。

类型可以使用任何名称，但只能有一个。

首选的类型名称是<code class="literal">_doc</code>，这样索引API就有了与 7.0 中相同的路径：<code class="literal">PUT {index}/_doc/{id}</code> 及 <code class="literal">POST {index}/_doc</code>
</li>
<li class="listitem">
<code class="literal">_type</code>名称不能再与<code class="literal">_id</code>组合形成字段<code class="literal">_uid</code>。

字段<code class="literal">_uid</code>已成为字段<code class="literal">_id</code>的别名。
</li>
<li class="listitem">
新的索引不再支持旧式的父/子索引，而应该使用<a class="xref" href="parent-join.html" title="join 数据类型" rel="nofollow"><code class="literal">join</code>字段</a>代替。
</li>
<li class="listitem">
<code class="literal">_default_</code>映射类型已废弃。
</li>
<li class="listitem">
在6.8中，索引创建、索引模板和映射API支持查询字符串参数(<code class="literal">include_type_name</code>)，该参数指示请求和响应是否应包含类型名称。

它默认为<code class="literal">true</code>，如果准备升级到 7.0 则应该显式的设置一个值。

没有显式类型的索引将使用名为<code class="literal">_doc</code>的虚拟类型。
</li>
</ul>
</div>
</dd>
<dt>
<span class="term">
Elasticsearch 7.x
</span>
</dt>
<dd>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
在请求中指定类型已被废弃。

例如，为文档编制索引不再需要文档<code class="literal">type</code>。

新的编制索引API在显式指定 id 的情况下是<code class="literal">PUT {index}/_doc/{id}</code>，在自动生成 id 的情况下<code class="literal">POST {index}/_doc</code>。

请注意，在 7.0 中，<code class="literal">_doc</code>是路径的永久部分，它表示终端名称，而不是文档类型。 
</li>
<li class="listitem">
索引创建、索引模板和映射API中的参数<code class="literal">include_type_name</code>将默认为<code class="literal">false</code>。

设置该参数将导致一个废弃警告。
</li>
<li class="listitem">
<code class="literal">_default_</code>映射类型已被删除。
</li>
</ul>
</div>
</dd>
<dt>
<span class="term">
Elasticsearch 8.x
</span>
</dt>
<dd>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
不再支持在请求中指定类型。
</li>
<li class="listitem">
参数<code class="literal">include_type_name</code>已被删除。
</li>
</ul>
</div>
</dd>
</dl>
</div>
<h3>
<a id="_migrating_multi_type_indices_to_single_type"></a>将多类型索引迁移到单一类型
</h3>
<p>
<a class="xref" href="docs-reindex.html" title="reindex API" rel="nofollow">重新索引(reindex) API</a>可用于将多类型索引转换为单一类型索引。

下面这个示例可用于 Elasticsearch 5.6 或 Elasticsearch 6.x。

在 6.x 中，不需要指定<code class="literal">index.mapping.single_type</code>，因为这是默认值。
</p>
<h4>
<a id="_index_per_document_type_2"></a>一个文档类型一个索引
</h4>
<p>
第一个例子将索引<code class="literal">twitter</code>切分为索引<code class="literal">tweets</code>和<code class="literal">users</code>：
</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">PUT users
{
  "settings": {
    "index.mapping.single_type": true
  },
  "mappings": {
    "_doc": {
      "properties": {
        "name": {
          "type": "text"
        },
        "user_name": {
          "type": "keyword"
        },
        "email": {
          "type": "keyword"
        }
      }
    }
  }
}

PUT tweets
{
  "settings": {
    "index.mapping.single_type": true
  },
  "mappings": {
    "_doc": {
      "properties": {
        "content": {
          "type": "text"
        },
        "user_name": {
          "type": "keyword"
        },
        "tweeted_at": {
          "type": "date"
        }
      }
    }
  }
}

POST _reindex
{
  "source": {
    "index": "twitter",
    "type": "user"
  },
  "dest": {
    "index": "users",
    "type": "_doc"
  }
}

POST _reindex
{
  "source": {
    "index": "twitter",
    "type": "tweet"
  },
  "dest": {
    "index": "tweets",
    "type": "_doc"
  }
}</pre>
</div>
<h4>
<a id="_custom_type_field_2"></a>Custom type field<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/removal_of_types.asciidoc">edit</a>
</h4>
<p>This next example adds a custom <code class="literal">type</code> field and sets it to the value of the
original <code class="literal">_type</code>.  It also adds the type to the <code class="literal">_id</code> in case there are any
documents of different types which have conflicting IDs:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">PUT new_twitter
{
  "mappings": {
    "_doc": {
      "properties": {
        "type": {
          "type": "keyword"
        },
        "name": {
          "type": "text"
        },
        "user_name": {
          "type": "keyword"
        },
        "email": {
          "type": "keyword"
        },
        "content": {
          "type": "text"
        },
        "tweeted_at": {
          "type": "date"
        }
      }
    }
  }
}


POST _reindex
{
  "source": {
    "index": "twitter"
  },
  "dest": {
    "index": "new_twitter"
  },
  "script": {
    "source": """
      ctx._source.type = ctx._type;
      ctx._id = ctx._type + '-' + ctx._id;
      ctx._type = '_doc';
    """
  }
}</pre>
</div>
<h3>
<a id="_typeless_apis_in_7_0"></a>Typeless APIs in 7.0<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/removal_of_types.asciidoc">edit</a>
</h3>
<p>In Elasticsearch 7.0, each API will support typeless requests,
and specifying a type will produce a deprecation warning.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Typeless APIs work even if the target index contains a custom type.
For example, if an index has the custom type name <code class="literal">my_type</code>, we can add
documents to it using typeless <code class="literal">index</code> calls, and load documents with typeless
<code class="literal">get</code> calls.</p>
</div>
</div>
<h4>
<a id="_index_apis"></a>Index APIs<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/removal_of_types.asciidoc">edit</a>
</h4>
<p>Index creation, index template, and mapping APIs support a new <code class="literal">include_type_name</code>
URL parameter that specifies whether mapping definitions in requests and responses
should contain the type name. The parameter defaults to <code class="literal">true</code> in version 6.8 to
match the pre-7.0 behavior of using type names in mappings. It defaults to <code class="literal">false</code>
in version 7.0 and will be removed in version 8.0.</p>
<p>It should be set explicitly in 6.8 to prepare to upgrade to 7.0. To avoid deprecation
warnings in 6.8, the parameter can be set to either <code class="literal">true</code> or <code class="literal">false</code>. In 7.0, setting
<code class="literal">include_type_name</code> at all will result in a deprecation warning.</p>
<p>See some examples of interactions with Elasticsearch with this option set to <code class="literal">false</code>:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT index?include_type_name=false
{
  "mappings": {
    "properties": { <a id="CO285-1"></a><i class="conum" data-value="1"></i>
      "foo": {
        "type": "keyword"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/607.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO285-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Mappings are included directly under the <code class="literal">mappings</code> key, without a type name.</p>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT index/_mappings?include_type_name=false
{
  "properties": { <a id="CO286-1"></a><i class="conum" data-value="1"></i>
    "bar": {
      "type": "text"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/608.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO286-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Mappings are included directly under the <code class="literal">mappings</code> key, without a type name.</p>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET index/_mappings?include_type_name=false</pre>
</div>
<div class="console_widget" data-snippet="snippets/609.console"></div>
<p>The above call returns</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "index": {
    "mappings": {
      "properties": { <a id="CO287-1"></a><i class="conum" data-value="1"></i>
        "foo": {
          "type": "keyword"
        },
        "bar": {
          "type": "text"
        }
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO287-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Mappings are included directly under the <code class="literal">mappings</code> key, without a type name.</p>
</td>
</tr>
</table>
</div>
<h4>
<a id="_document_apis"></a>Document APIs<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/removal_of_types.asciidoc">edit</a>
</h4>
<p>In 7.0, index APIs must be called with the <code class="literal">{index}/_doc</code> path for automatic
generation of the <code class="literal">_id</code> and <code class="literal">{index}/_doc/{id}</code> with explicit ids.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT index/_doc/1
{
  "foo": "baz"
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/610.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "_index": "index",
  "_id": "1",
  "_type": "_doc",
  "_version": 1,
  "result": "created",
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "_seq_no": 0,
  "_primary_term": 1
}</pre>
</div>
<p>Similarly, the <code class="literal">get</code> and <code class="literal">delete</code> APIs use the path <code class="literal">{index}/_doc/{id}</code>:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET index/_doc/1</pre>
</div>
<div class="console_widget" data-snippet="snippets/611.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In 7.0, <code class="literal">_doc</code> represents the endpoint name instead of the document type.
The <code class="literal">_doc</code> component is a permanent part of the path for the document <code class="literal">index</code>,
<code class="literal">get</code>, and <code class="literal">delete</code> APIs going forward, and will not be removed in 8.0.</p>
</div>
</div>
<p>For API paths that contain both a type and endpoint name like <code class="literal">_update</code>,
in 7.0 the endpoint will immediately follow the index name:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST index/_update/1
{
    "doc" : {
        "foo" : "qux"
    }
}

GET /index/_source/1</pre>
</div>
<div class="console_widget" data-snippet="snippets/612.console"></div>
<p>Types should also no longer appear in the body of requests. The following
example of bulk indexing omits the type both in the URL, and in the individual
bulk commands:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST _bulk
{ "index" : { "_index" : "index", "_id" : "3" } }
{ "foo" : "baz" }
{ "index" : { "_index" : "index", "_id" : "4" } }
{ "foo" : "qux" }</pre>
</div>
<div class="console_widget" data-snippet="snippets/613.console"></div>
<h4>
<a id="_search_apis"></a>Search APIs<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/removal_of_types.asciidoc">edit</a>
</h4>
<p>When calling a search API such <code class="literal">_search</code>, <code class="literal">_msearch</code>, or <code class="literal">_explain</code>, types
should not be included in the URL. Additionally, the <code class="literal">_type</code> field should not
be used in queries, aggregations, or scripts.</p>
<h4>
<a id="_types_in_responses"></a>Types in responses<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/removal_of_types.asciidoc">edit</a>
</h4>
<p>The document and search APIs will continue to return a <code class="literal">_type</code> key in
responses, to avoid breaks to response parsing. However, the key is
considered deprecated and should no longer be referenced. Types will
be completely removed from responses in 8.0.</p>
<p>Note that when a deprecated typed API is used, the index’s mapping type will be
returned as normal, but that typeless APIs will return the dummy type <code class="literal">_doc</code>
in the response. For example, the following typeless <code class="literal">get</code> call will always
return <code class="literal">_doc</code> as the type, even if the mapping has a custom type name like
<code class="literal">my_type</code>:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT index/my_type/1
{
  "foo": "baz"
}

GET index/_doc/1</pre>
</div>
<div class="console_widget" data-snippet="snippets/614.console"></div>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
    "_index" : "index",
    "_type" : "_doc",
    "_id" : "1",
    "_version" : 1,
    "_seq_no" : 0,
    "_primary_term" : 1,
    "found": true,
    "_source" : {
        "foo" : "baz"
    }
}</pre>
</div>
<h4>
<a id="_index_templates"></a>Index templates<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/removal_of_types.asciidoc">edit</a>
</h4>
<p>It is recommended to make index templates typeless by re-adding them with
<code class="literal">include_type_name</code> set to <code class="literal">false</code>. Under the hood, typeless templates will use
the dummy type <code class="literal">_doc</code> when creating indices.</p>
<p>In case typeless templates are used with typed index creation calls or typed
templates are used with typeless index creation calls, the template will still
be applied but the index creation call decides whether there should be a type
or not. For instance in the below example, <code class="literal">index-1-01</code> will have a type in
spite of the fact that it matches a template that is typeless, and <code class="literal">index-2-01</code>
will be typeless in spite of the fact that it matches a template that defines
a type. Both <code class="literal">index-1-01</code> and <code class="literal">index-2-01</code> will inherit the <code class="literal">foo</code> field from
the template that they match.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _template/template1
{
  "index_patterns":[ "index-1-*" ],
  "mappings": {
    "properties": {
      "foo": {
        "type": "keyword"
      }
    }
  }
}

PUT _template/template2?include_type_name=true
{
  "index_patterns":[ "index-2-*" ],
  "mappings": {
    "type": {
      "properties": {
        "foo": {
          "type": "keyword"
        }
      }
    }
  }
}

PUT index-1-01?include_type_name=true
{
  "mappings": {
    "type": {
      "properties": {
        "bar": {
          "type": "long"
        }
      }
    }
  }
}

PUT index-2-01
{
  "mappings": {
    "properties": {
      "bar": {
        "type": "long"
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/615.console"></div>
<p>In case of implicit index creation, because of documents that get indexed in
an index that doesn’t exist yet, the template is always honored. This is
usually not a problem due to the fact that typeless index calls work on typed
indices.</p>
<h4>
<a id="_mixed_version_clusters"></a>Mixed-version clusters<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/mapping/removal_of_types.asciidoc">edit</a>
</h4>
<p>In a cluster composed of both 6.8 and 7.0 nodes, the parameter
<code class="literal">include_type_name</code> should be specified in index APIs like index
creation. This is because the parameter has a different default between
6.8 and 7.0, so the same mapping definition will not be valid for both
node versions.</p>
<p>Typeless document APIs such as <code class="literal">bulk</code> and <code class="literal">update</code> are only available as of
7.0, and will not work with 6.8 nodes. This also holds true for the typeless
versions of queries that perform document lookups, such as <code class="literal">terms</code>.</p>
</div>
<div class="navfooter">
<span class="prev">
<a href="mapping.html">« 映射</a>
</span>
<span class="next">
<a href2="mapping-types.html">Field datatypes »</a>
</span>
</div>
</div>

                  <!-- end body -->
                        </div>
                        <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                        
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </section>
</div>
<script src="../static/cn.js"></script>
</body>
</html>