<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>composite 聚合 | ElasticSearch 7.7 权威指南中文版</title>
	<meta name="keywords" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <meta name="description" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
	<link rel="stylesheet" type="text/css" href="../static/styles.css" />
	<script>
	var _link = 'search-aggregations-bucket-composite-aggregation.html';
    </script>
</head>
<body>
<div class="main-container">
    <section id="content">
        <div class="content-wrapper">
            <section id="guide" lang="zh_cn">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                            <div style="color:gray; word-break: break-all; font-size:12px;">原英文版地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-bucket-composite-aggregation.html" rel="nofollow" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-bucket-composite-aggregation.html</a>, 原文档版权归 www.elastic.co 所有<br/>本地英文版地址: <a href="../en/search-aggregations-bucket-composite-aggregation.html" rel="nofollow" target="_blank">../en/search-aggregations-bucket-composite-aggregation.html</a></div>
                        <!-- start body -->
                  <div class="page_header">
<strong>重要</strong>: 此版本不会发布额外的bug修复或文档更新。最新信息请参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="nofollow">当前版本文档</a>。
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch 权威指南 [7.7]</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations.html">聚合</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations-bucket.html">桶(bucket)聚合</a></span>
»
<span class="breadcrumb-node">composite 聚合</span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-bucket-children-aggregation.html">« children 聚合</a>
</span>
<span class="next">
<a href2="search-aggregations-bucket-datehistogram-aggregation.html">Date histogram aggregation »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title">
<a id="search-aggregations-bucket-composite-aggregation"></a>复合(composite)聚合
</h2>
</div></div></div>
<p>一个多桶(multi-bucket)聚合，从不同来源创建复合桶。</p>
<p>
与其他<code class="literal">多桶(multi-bucket)</code>聚合不同，<code class="literal">composite</code> 聚合可用于高效地对多级聚合中的<span class="strong strong"><strong>所有</strong></span>桶进行分页。

这种聚合提供了一种方法，类似于 <a class="xref" href="search-request-body.html#request-body-search-scroll" title="scroll" rel="nofollow">scroll</a> 对文档所做的那样，对特定聚合的所有桶进行流式处理。
</p>
<p>复合桶是从为每个文档提取/创建的值的组合中构建的，并且每个组合被认为是一个复合桶。</p>
<p>比如下面的文档：</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "keyword": ["foo", "bar"],
    "number": [23, 65, 76]
}</pre>
</div>
<p>
... 当<code class="literal">keyword</code> 和 <code class="literal">number</code>用作聚合的值的来源时，创建以下复合桶：
</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{ "keyword": "foo", "number": 23 }
{ "keyword": "foo", "number": 65 }
{ "keyword": "foo", "number": 76 }
{ "keyword": "bar", "number": 23 }
{ "keyword": "bar", "number": 65 }
{ "keyword": "bar", "number": 76 }</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_values_source_2"></a>值的来源<span class="remark">(value source)</span>
</h3>
</div></div></div>
<p>
参数 <code class="literal">sources</code> 控制应该用于构建复合桶的源。

定义 <code class="literal">sources</code> 的顺序很重要，因为它也控制着 key 的返回顺序。
</p>
<p>每个源的名称必须是唯一的。</p>
<p>值的来源有三种不同类型：</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_terms"></a>terms <span class="remark">（词项）</span>
</h4>
</div></div></div>
<p>
<code class="literal">terms</code> 值来源相当于一个简单的 <code class="literal">terms</code> 集合。

这些值是从字段或脚本中提取的，就像 <code class="literal">terms</code> 聚合一样。
</p>
<p>例如：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "product": { "terms" : { "field": "product" } } }
                ]
            }
        }
     }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/423.console"></div>
<p>与 <code class="literal">terms</code> 聚合一样，也可以使用脚本来创建复合桶的值：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    {
                        "product": {
                            "terms" : {
                                "script" : {
                                    "source": "doc['product'].value",
                                    "lang": "painless"
                                }
                            }
                        }
                    }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/424.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_histogram"></a>histogram <span class="remark">（直方图）</span>
</h4>
</div></div></div>
<p>
<code class="literal">histogram</code> 值来源可应用于数值，以在这些值上构建固定大小的间隔。

参数 <code class="literal">interval</code> 定义应该如何转换数值。

例如， <code class="literal">interval</code> 设置为 5 会将任何数值转换为最接近 5 的间隔，值 <code class="literal">101</code> 会转换为 <code class="literal">100</code>，因为 101 在间隔 100 和 105 之间。
</p>
<p>例如：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "histo": { "histogram" : { "field": "price", "interval": 5 } } }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/425.console"></div>
<p>这些值由 numeric(数值)字段或返回数值的脚本构建而成：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    {
                        "histo": {
                            "histogram" : {
                                "interval": 5,
                                "script" : {
                                    "source": "doc['price'].value",
                                    "lang": "painless"
                                }
                            }
                        }
                    }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/426.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_date_histogram"></a>date histogram <span class="remark">(日期直方图)</span>
</h4>
</div></div></div>
<p><code class="literal">date_histogram</code>值源类似于 <code class="literal">histogram</code>，只是它的时间间隔是由日期/时间表达式指定的：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "date": { "date_histogram" : { "field": "timestamp", "calendar_interval": "1d" } } }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/427.console"></div>
<p>
上面的示例创建了一个每天的时间间隔，并将所有 <code class="literal">timestamp</code> 值转换为最接近的时间间隔的开始。

间隔的可用表达式有：<code class="literal">year</code>、<code class="literal">quarter</code>, <code class="literal">month</code>、<code class="literal">week</code>、<code class="literal">day</code>、<code class="literal">hour</code>、<code class="literal">minute</code>、<code class="literal">second</code>。
</p>
<p>
时间值也可以通过<a class="xref" href="common-options.html#time-units" title="Time units" rel="nofollow">时间单位(time units)</a>解析支持的缩写来指定。

请注意，不支持带小数点的时间值，但是你可以通过转换到另一个时间单位来解决这个问题(例如，可以将<code class="literal">1.5h</code>指定为<code class="literal">90m</code>)。
</p>
<p>&nbsp;</p>
<p><span class="strong strong"><strong>format</strong></span></p>
<p>
在内部，一个日期被表示为一个64位的数字-一个时间戳，以毫秒为单位。 

这些时间戳作为桶的 key 返回。

可以使用参数<code class="literal">format</code>指定的格式返回格式化的日期字符串：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    {
                        "date": {
                            "date_histogram" : {
                                "field": "timestamp",
                                "calendar_interval": "1d",
                                "format": "yyyy-MM-dd" <a id="CO215-1"></a><i class="conum" data-value="1"></i>
                            }
                        }
                    }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/428.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO215-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>支持<a class="xref" href="search-aggregations-bucket-daterange-aggregation.html#date-format-pattern" title="date 格式/模式" rel="nofollow">日期格式/模式</a>表达式</p>
</td>
</tr>
</table>
</div>
<p><span class="strong strong"><strong>时区</strong></span></p>
<p>
日期时间以 UTC 存储在 Elasticsearch 中。

默认情况下，所有的分桶和舍入也在 UTC 中完成。

<code class="literal">time_zone</code> 参数可用于指示分桶时应该使用不同的时区。
</p>
<p>
时区可以指定为 ISO 8601 UTC 时差(例如<code class="literal">+01:00</code> 或 <code class="literal">-08:00</code>)，也可以指定为时区id(在TZ数据库中使用的标识符)，比如<code class="literal">America/Los_Angeles</code>。
</p>
<p><span class="strong strong"><strong>Offset</strong></span></p>
<p>Use the <code class="literal">offset</code> parameter to change the start value of each bucket by the
specified positive (<code class="literal">+</code>) or negative offset (<code class="literal">-</code>) duration, such as <code class="literal">1h</code> for
an hour, or <code class="literal">1d</code> for a day. See <a class="xref" href="common-options.html#time-units" title="Time units">Time units</a> for more possible time
duration options.</p>
<p>For example, when using an interval of <code class="literal">day</code>, each bucket runs from midnight
to midnight. Setting the <code class="literal">offset</code> parameter to <code class="literal">+6h</code> changes each bucket
to run from 6am to 6am:</p>
<a id="composite-aggregation-datehistogram-offset-example"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT my_index/_doc/1?refresh
{
  "date": "2015-10-01T05:30:00Z"
}

PUT my_index/_doc/2?refresh
{
  "date": "2015-10-01T06:30:00Z"
}

GET my_index/_search?size=0
{
  "aggs": {
    "my_buckets": {
      "composite" : {
        "sources" : [
          {
            "date": {
              "date_histogram" : {
                "field": "date",
                "calendar_interval": "day",
                "offset": "+6h",
                "format": "iso8601"
              }
            }
          }
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/429.console"></div>
<p>Instead of a single bucket starting at midnight, the above request groups the
documents into buckets starting at 6am:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": { "date": "2015-10-01T06:00:00.000Z" },
      "buckets": [
        {
          "key": { "date": "2015-09-30T06:00:00.000Z" },
          "doc_count": 1
        },
        {
          "key": { "date": "2015-10-01T06:00:00.000Z" },
          "doc_count": 1
        }
      ]
    }
  }
}</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The start <code class="literal">offset</code> of each bucket is calculated after <code class="literal">time_zone</code>
adjustments have been made.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_mixing_different_values_source"></a>Mixing different values source<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The <code class="literal">sources</code> parameter accepts an array of values source.
It is possible to mix different values source to create composite buckets.
For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } },
                    { "product": { "terms": {"field": "product" } } }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/430.console"></div>
<p>This will create composite buckets from the values created by two values source, a <code class="literal">date_histogram</code> and a <code class="literal">terms</code>.
Each bucket is composed of two values, one for each value source defined in the aggregation.
Any type of combinations is allowed and the order in the array is preserved
in the composite buckets.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "shop": { "terms": {"field": "shop" } } },
                    { "product": { "terms": { "field": "product" } } },
                    { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/431.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_order"></a>Order<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>By default the composite buckets are sorted by their natural ordering. Values are sorted
in ascending order of their values. When multiple value sources are requested, the ordering is done per value
source, the first value of the composite bucket is compared to the first value of the other composite bucket and if they are equals the
next values in the composite bucket are used for tie-breaking. This means that the composite bucket
 <code class="literal">[foo, 100]</code> is considered smaller than <code class="literal">[foobar, 0]</code> because <code class="literal">foo</code> is considered smaller than <code class="literal">foobar</code>.
It is possible to define the direction of the sort for each value source by setting <code class="literal">order</code> to <code class="literal">asc</code> (default value)
or <code class="literal">desc</code> (descending order) directly in the value source definition.
For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
                    { "product": { "terms": {"field": "product", "order": "asc" } } }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/432.console"></div>
<p>... will sort the composite bucket in descending order when comparing values from the <code class="literal">date_histogram</code> source
and in ascending order when comparing values from the <code class="literal">terms</code> source.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_missing_bucket"></a>Missing bucket<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>By default documents without a value for a given source are ignored.
It is possible to include them in the response by setting <code class="literal">missing_bucket</code> to
<code class="literal">true</code> (defaults to <code class="literal">false</code>):</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "product_name": { "terms" : { "field": "product", "missing_bucket": true } } }
                ]
            }
        }
     }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/433.console"></div>
<p>In the example above the source <code class="literal">product_name</code> will emit an explicit <code class="literal">null</code> value
for documents without a value for the field <code class="literal">product</code>.
The <code class="literal">order</code> specified in the source dictates whether the <code class="literal">null</code> values should rank
first (ascending order, <code class="literal">asc</code>) or last (descending order, <code class="literal">desc</code>).</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_size_2"></a>Size<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many composite buckets should be returned.
Each composite bucket is considered as a single bucket so setting a size of 10 will return the
first 10 composite buckets created from the values source.
The response contains the values for each composite bucket in an array containing the values extracted
from each value source.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_pagination"></a>Pagination<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>If the number of composite buckets is too high (or unknown) to be returned in a single response
it is possible to split the retrieval in multiple requests.
Since the composite buckets are flat by nature, the requested <code class="literal">size</code> is exactly the number of composite buckets
that will be returned in the response (assuming that they are at least <code class="literal">size</code> composite buckets to return).
If all composite buckets should be retrieved it is preferable to use a small size (<code class="literal">100</code> or <code class="literal">1000</code> for instance)
and then use the <code class="literal">after</code> parameter to retrieve the next results.
For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "size": 2,
                "sources" : [
                    { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } },
                    { "product": { "terms": {"field": "product" } } }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/434.console"></div>
<p>... returns:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
    ...
    "aggregations": {
        "my_buckets": {
            "after_key": {
                "date": 1494288000000,
                "product": "mad max"
            },
            "buckets": [
                {
                    "key": {
                        "date": 1494201600000,
                        "product": "rocky"
                    },
                    "doc_count": 1
                },
                {
                    "key": {
                        "date": 1494288000000,
                        "product": "mad max"
                    },
                    "doc_count": 2
                }
            ]
        }
    }
}</pre>
</div>
<p>To get the next set of buckets, resend the same aggregation with the <code class="literal">after</code>
parameter set to the <code class="literal">after_key</code> value returned in the response.
For example, this request uses the <code class="literal">after_key</code> value provided in the previous response:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "size": 2,
                 "sources" : [
                    { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
                    { "product": { "terms": {"field": "product", "order": "asc" } } }
                ],
                "after": { "date": 1494288000000, "product": "mad max" } <a id="CO216-1"></a><i class="conum" data-value="1"></i>
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/435.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO216-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Should restrict the aggregation to buckets that sort <span class="strong strong"><strong>after</strong></span> the provided values.</p>
</td>
</tr>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">after_key</code> is <span class="strong strong"><strong>usually</strong></span> the key to the last bucket returned in
the response, but that isn’t guaranteed. Always use the returned <code class="literal">after_key</code> instead
of derriving it from the buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_early_termination"></a>Early termination<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>For optimal performance the <a class="xref" href="index-modules-index-sorting.html" title="Index Sorting">index sort</a> should be set on the index so that it matches
parts or fully the source order in the composite aggregation.
For instance the following index sort:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT twitter
{
    "settings" : {
        "index" : {
            "sort.field" : ["username", "timestamp"],   <a id="CO217-1"></a><i class="conum" data-value="1"></i>
            "sort.order" : ["asc", "desc"]              <a id="CO217-2"></a><i class="conum" data-value="2"></i>
        }
    },
    "mappings": {
        "properties": {
            "username": {
                "type": "keyword",
                "doc_values": true
            },
            "timestamp": {
                "type": "date"
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/436.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO217-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>This index is sorted by <code class="literal">username</code> first then by <code class="literal">timestamp</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO217-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>…​ in ascending order for the <code class="literal">username</code> field and in descending order for the <code class="literal">timestamp</code> field.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
could be used to optimize these composite aggregations:
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "user_name": { "terms" : { "field": "user_name" } } }     <a id="CO218-1"></a><i class="conum" data-value="1"></i>
                ]
            }
        }
     }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/437.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO218-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">user_name</code> is a prefix of the index sort and the order matches (<code class="literal">asc</code>).</p>
</td>
</tr>
</table>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "user_name": { "terms" : { "field": "user_name" } } }, <a id="CO219-1"></a><i class="conum" data-value="1"></i>
                    { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } } <a id="CO219-2"></a><i class="conum" data-value="2"></i>
                ]
            }
        }
     }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/438.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO219-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">user_name</code> is a prefix of the index sort and the order matches (<code class="literal">asc</code>).</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO219-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">timestamp</code> matches also the prefix and the order matches (<code class="literal">desc</code>).</p>
</td>
</tr>
</table>
</div>
<p>In order to optimize the early termination it is advised to set <code class="literal">track_total_hits</code> in the request
to <code class="literal">false</code>. The number of total hits that match the request can be retrieved on the first request
and it would be costly to compute this number on every page:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "track_total_hits": false,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                "sources" : [
                    { "user_name": { "terms" : { "field": "user_name" } } },
                    { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } }
                ]
            }
        }
     }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/439.console"></div>
<p>Note that the order of the source is important, in the example below switching the <code class="literal">user_name</code> with the <code class="literal">timestamp</code>
would deactivate the sort optimization since this configuration wouldn’t match the index sort specification.
If the order of sources do not matter for your use case you can follow these simple guidelines:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Put the fields with the highest cardinality first.
</li>
<li class="listitem">
Make sure that the order of the field matches the order of the index sort.
</li>
<li class="listitem">
Put multi-valued fields last since they cannot be used for early termination.
</li>
</ul>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p><a class="xref" href="index-modules-index-sorting.html" title="Index Sorting">index sort</a> can slowdown indexing, it is very important to test index sorting
with your specific use case and dataset to ensure that it matches your requirement. If it doesn’t note that <code class="literal">composite</code>
aggregations will also try to early terminate on non-sorted indices if the query matches all document (<code class="literal">match_all</code> query).</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_sub_aggregations"></a>Sub-aggregations<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>Like any <code class="literal">multi-bucket</code> aggregations the <code class="literal">composite</code> aggregation can hold sub-aggregations.
These sub-aggregations can be used to compute other buckets or statistics on each composite bucket created by this
parent aggregation.
For instance the following example computes the average value of a field
per composite bucket:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "size": 0,
    "aggs" : {
        "my_buckets": {
            "composite" : {
                 "sources" : [
                    { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
                    { "product": { "terms": {"field": "product" } } }
                ]
            },
            "aggregations": {
                "the_avg": {
                    "avg": { "field": "price" }
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/440.console"></div>
<p>... returns:</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
    ...
    "aggregations": {
        "my_buckets": {
            "after_key": {
                "date": 1494201600000,
                "product": "rocky"
            },
            "buckets": [
                {
                    "key": {
                        "date": 1494460800000,
                        "product": "apocalypse now"
                    },
                    "doc_count": 1,
                    "the_avg": {
                        "value": 10.0
                    }
                },
                {
                    "key": {
                        "date": 1494374400000,
                        "product": "mad max"
                    },
                    "doc_count": 1,
                    "the_avg": {
                        "value": 27.0
                    }
                },
                {
                    "key": {
                        "date": 1494288000000,
                        "product" : "mad max"
                    },
                    "doc_count": 2,
                    "the_avg": {
                        "value": 22.5
                    }
                },
                {
                    "key": {
                        "date": 1494201600000,
                        "product": "rocky"
                    },
                    "doc_count": 1,
                    "the_avg": {
                        "value": 10.0
                    }
                }
            ]
        }
    }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_pipeline_aggregations"></a>Pipeline aggregations<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/composite-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>The composite agg is not currently compatible with pipeline aggregations, nor does it make sense in most cases.
E.g. due to the paging nature of composite aggs, a single logical partition (one day for example) might be spread
over multiple pages.  Since pipeline aggregations are purely post-processing on the final list of buckets,
running something like a derivative on a composite page could lead to inaccurate results as it is only taking into
account a "partial" result on that page.</p>
<p>Pipeline aggs that are self contained to a single bucket (such as <code class="literal">bucket_selector</code>) might be supported in the future.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations-bucket-children-aggregation.html">« children 聚合</a>
</span>
<span class="next">
<a href2="search-aggregations-bucket-datehistogram-aggregation.html">Date histogram aggregation »</a>
</span>
</div>
</div>

                  <!-- end body -->
                        </div>
                        <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                        
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </section>
</div>
<script src="../static/cn.js"></script>
</body>
</html>