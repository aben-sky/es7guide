<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>significant_terms 聚合 | ElasticSearch 7.7 权威指南中文版</title>
	<meta name="keywords" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <meta name="description" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
	<link rel="stylesheet" type="text/css" href="../static/styles.css" />
	<script>
	var _link = 'search-aggregations-bucket-significantterms-aggregation.html';
    </script>
</head>
<body>
<div class="main-container">
    <section id="content">
        <div class="content-wrapper">
            <section id="guide" lang="zh_cn">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                            <div style="color:gray; word-break: break-all; font-size:12px;">原英文版地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-bucket-significantterms-aggregation.html" rel="nofollow" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-bucket-significantterms-aggregation.html</a>, 原文档版权归 www.elastic.co 所有<br/>本地英文版地址: <a href="../en/search-aggregations-bucket-significantterms-aggregation.html" rel="nofollow" target="_blank">../en/search-aggregations-bucket-significantterms-aggregation.html</a></div>
                        <!-- start body -->
                  <div class="page_header">
<strong>重要</strong>: 此版本不会发布额外的bug修复或文档更新。最新信息请参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="nofollow">当前版本文档</a>。
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch 权威指南 [7.7]</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations.html">聚合</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations-bucket.html">桶(bucket)聚合</a></span>
»
<span class="breadcrumb-node">significant_terms 聚合</span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-bucket-sampler-aggregation.html">« sampler 聚合</a>
</span>
<span class="next">
<a href2="search-aggregations-bucket-significanttext-aggregation.html">Significant Text Aggregation »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title">
<a id="search-aggregations-bucket-significantterms-aggregation"></a>重要词项(significant_terms)聚合
</h2>
</div></div></div>
<p>一种聚合，返回集合中有趣或不寻常的词项的聚合。 </p>
<div class="ulist itemizedlist">
<p class="title"><strong>用例示例：</strong></p>
<ul class="itemizedlist">
<li class="listitem">
当用户在文本中搜索“禽流感”时，提示“H5N1”
</li>
<li class="listitem">
从信用卡持有人挂失的交易历史中确定“妥协点”的商家
</li>
<li class="listitem">
为自动新闻分类器建议与股票代码$ATI相关的关键词
</li>
<li class="listitem">
发现那个诊断出更多鞭伤的骗子医生
</li>
<li class="listitem">
发现爆胎数量不成比例的轮胎制造商
</li>
</ul>
</div>
<p>
在这几种情况下，被选择的词项不仅仅都是一组最流行的词项。

它们是在<em>前景(foreground)</em>和<em>背景(background)</em>集合之间受欢迎程度发生了显著变化的词项。

如果词项“H5N1”仅存在于1000万个文档索引中的5个文档中，但是在构成用户搜索结果的100个文档中的4个中出现，则这是重要的并且可能与他们的搜索非常相关。

频率 5/10,000,000 与 4/100 相比差别很大。
</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_single_set_analysis"></a>单个集合分析(Single-set analysis)
</h3>
</div></div></div>
<p>
在最简单的情况下，感兴趣的<em>前景(foreground)</em>集是与查询匹配的搜索结果，而用于统计比较的<em>背景(background)</em>集则是从中收集结果的一个或多个索引。
</p>
<p>示例：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "terms" : {"force" : [ "British Transport Police" ]}
    },
    "aggregations" : {
        "significant_crime_types" : {
            "significant_terms" : { "field" : "crime_type" }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/511.console"></div>
<p>响应：</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
    ...
    "aggregations" : {
        "significant_crime_types" : {
            "doc_count": 47347,
            "bg_count": 5064554,
            "buckets" : [
                {
                    "key": "Bicycle theft",
                    "doc_count": 3640,
                    "score": 0.371235374214817,
                    "bg_count": 66799
                }
                ...
            ]
        }
    }
}</pre>
</div>
<p>
当查询一个所有警察部队的所有犯罪的索引时，这些结果表明，英国交通警察部队（British Transport Police）在处理不成比例的大量自行车盗窃案件中表现突出。

通常情况下，自行车盗窃只占犯罪的1%(66799/5064554)，但对于负责处理铁路和车站犯罪的英国交通警察来说，7%的犯罪(3640/47347)是自行车盗窃。

这在频率上显著增加了七倍，因此这种异常被强调为最常见的犯罪类型。
</p>
<p>
用查询来发现异常的问题是，它只给了我们一个用于比较的子集。

为了发现所有其他警察部队的异常情况，我们必须对每个不同的部队重复查询。
</p>
<p>这可能是一种在索引中寻找不寻常模式的乏味方法 </p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_multi_set_analysis"></a>多个集合分析(Multi-set analysis)
</h3>
</div></div></div>
<p>跨多个类别执行分析的一种更简单的方法是使用父级聚合对数据进行分段，以便进行分析。</p>
<p>使用父聚合进行分段的示例：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggregations": {
        "forces": {
            "terms": {"field": "force"},
            "aggregations": {
                "significant_crime_types": {
                    "significant_terms": {"field": "crime_type"}
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/512.console"></div>
<p>响应：</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
 ...
 "aggregations": {
    "forces": {
        "doc_count_error_upper_bound": 1375,
        "sum_other_doc_count": 7879845,
        "buckets": [
            {
                "key": "Metropolitan Police Service",
                "doc_count": 894038,
                "significant_crime_types": {
                    "doc_count": 894038,
                    "bg_count": 5064554,
                    "buckets": [
                        {
                            "key": "Robbery",
                            "doc_count": 27617,
                            "score": 0.0599,
                            "bg_count": 53182
                        }
                        ...
                    ]
                }
            },
            {
                "key": "British Transport Police",
                "doc_count": 47347,
                "significant_crime_types": {
                    "doc_count": 47347,
                    "bg_count": 5064554,
                    "buckets": [
                        {
                            "key": "Bicycle theft",
                            "doc_count": 3640,
                            "score": 0.371,
                            "bg_count": 66799
                        }
                        ...
                    ]
                }
            }
        ]
    }
  }
}</pre>
</div>
<p>现在，我们只需一个请求，就可以对每支警察部队进行异常检测。</p>
<p>我们可以使用其他形式的顶级聚合来划分数据，例如按地理区域划分，以识别特定犯罪类型的异常热点：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs": {
        "hotspots": {
            "geohash_grid": {
                "field": "location",
                "precision": 5
            },
            "aggs": {
                "significant_crime_types": {
                    "significant_terms": {"field": "crime_type"}
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/513.console"></div>
<p>上面这个示例使用<code class="literal">geohash_grid</code>聚合来创建代表地理区域的结果桶，在每个桶中，我们可以识别这些高度集中的区域中犯罪类型的异常级别，例如：</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
机场缴获武器的数量之多的异常
</li>
<li class="listitem">
大学里自行车盗窃的上升趋势
</li>
</ul>
</div>
<p>在更高的geohash_grid缩放级别和更大的覆盖区域，我们将开始看到整个警察部队可能正在处理特定犯罪类型的异常数量。</p>
<p>
显然，基于时间的顶级分段将有助于识别每个时间点的当前趋势，其中简单的<code class="literal">terms</code>聚合通常会显示在所有时间段持续存在的非常流行的“常数(constants)”。
</p>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>分数是如何计算的?</strong></p>
</div></div></div>
<p>
返回的分数主要是为了对不同的建议进行合理的排名，而不是为了让最终用户容易理解。

分数是从<em>前景(foreground)</em>和<em>背景(background)</em>集中的文档频率得出的。

简而言之，如果一个词项在子集和背景中出现的频率有显著差异，则认为该词项是重要的。

可以配置术语的排列方式，请参见“参数”部分。
</p>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_use_on_free_text_fields"></a>在自定义文本(free-text)字段上使用
</h3>
</div></div></div>
<p>significant_terms聚合可以有效地用于词元化(tokenized)的自定义文本(free-text)字段，以建议：</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
优化最终用户搜索的关键字
</li>
<li class="listitem">
用于percolator查询的关键字
</li>
</ul>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>
选择一个自定义文本(free-text)作为重要词项分析的主题的成本可能会很高！

它会尝试将每个唯一的词加载到内存中。

建议仅在较小的索引上使用此选项。 
</p>
</div>
</div>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>使用<em>"像这样但又不是这样(like this but not this)"</em>模式</strong></p>
</div></div></div>
<p>
你可以通过首先搜索结构化字段，例如<code class="literal">category:adultMovie</code>，并在自定义文本“movie_description”字段中使用 significant_terms 来识别错误分类的内容。

使用建议的词(我会让你自己想象)，然后搜索所有<b>没有</b>标记为 category:adultMovie 但包含这些关键词的电影。

你现在有一个分类糟糕的电影的排名列表，你应该重新分类或至少从“familyFriendly”类别中删除。 
</p>
<p>
每个词项的重要性分数也可以提供一个有用的<code class="literal">boost</code>设置来对匹配进行排序。

使用带有关键字的<code class="literal">terms</code>查询的 minimum_should_match 设置将有助于控制结果集中的精确度/召回率的平衡，即高设置将使少量相关结果充满关键字，而设置“1”将产生包含<em>任何</em>关键字的所有文档的更详尽的结果集。
</p>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>
<strong>在上下文中显示 significant_terms</strong><br/>

自定义文本的 significant_terms 在上下文中更容易理解。

从自定义文本字段中获取<code class="literal">significant_terms</code>建议的结果，并在带有<code class="literal">highlight</code>子句的相同字段上的<code class="literal">terms</code>查询中使用它们，以向用户呈现文档的示例片段。

当词项不加词根、高亮显示、并以正确的大小写、正确的顺序和特定的上下文出现时，它们的重要性/意义就会更明显。 
</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_custom_background_sets"></a>自定义背景集(Custom background sets)
</h3>
</div></div></div>
<p>
通常，前景文档集与索引中所有文档的背景集是“不同”的。

然而，有时使用较窄的背景集作为比较的基础可能证明是有用的。

例如，在包含世界各地内容的索引中查询与“Madrid”相关的文档，可能会发现“Spanish”是一个重要的词项。

这可能是真的，但是如果你想要一些更集中的词项，你可以对词项<em>spain</em>使用<code class="literal">background_filter</code>来建立一个更窄的文档集作为上下文。

有了这一背景，“Spanish”现在会被视为司空见惯的，因此没有像“capital”这样与Madrid联系更紧密的词那么重要。

请注意，使用 background_filter 会减慢速度——每个词项的背景频率现在必须从过滤发布列表中即时获得，而不是读取索引中为某个词项预先计算的计数。
</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_limitations_5"></a>局限性
</h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_significant_terms_must_be_indexed_values"></a>重要词项必须是索引值
</h4>
</div></div></div>
<p>
与 terms 聚合不同，目前无法使用脚本生成的词项进行计数。

由于 significant_terms 聚合必须考虑<em>前景</em>和<em>背景</em>频率，因此在整个索引上使用脚本来获取背景频率进行比较的成本非常高。

出于类似的原因，文档值(DocValues)也不支持作为词项数据的来源。
</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_no_analysis_of_floating_point_fields"></a>不分析浮点(float)字段
</h4>
</div></div></div>
<p>
目前不支持浮点字段作为 significant_terms 分析的主题。

虽然整型(integer)或长整形(long)字段可用于表示银行账号或类别号等概念，跟踪这些概念可能会很有趣，但浮点型(float)字段通常用于表示数量。

因此，单个浮点项对于这种形式的频率分析没有用处。
</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_use_as_a_parent_aggregation"></a>作为父聚合(parent aggregation)使用
</h4>
</div></div></div>
<p>
如果存在<code class="literal">match_all</code>查询的等价查询，或者没有提供索引子集的查询标准，则 significant_terms 聚合不应用作最顶层的聚合——在这种情况下，<em>前景</em>集与<em>背景</em>集完全相同，因此在要观察的文档频率和从中做出合理建议的文档频率方面没有差异。
</p>
<p>
另一个考虑因素是 significant_terms 聚合在分片级别产生许多候选结果，这些结果只是在所有分片的所有统计信息合并后，在缩减节点(reducing node)上进行删减。

因此，从内存的角度来说，将大型子聚合嵌入到一个 significant_terms 聚合下是低效和昂贵的，这个聚合稍后会丢弃许多候选词项。 

在这些情况下，建议执行两次搜索——第一次是提供一个合理化的 significant_terms 列表，然后将这个词项列表添加到第二次查询中，以便返回并获取所需的子聚合。
</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_approximate_counts"></a>Approximate counts<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and
as such may be:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
low if certain shards did not provide figures for a given term in their top sample
</li>
<li class="listitem">
high when considering the background frequency as it may count occurrences found in deleted documents
</li>
</ul>
</div>
<p>Like most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.
However, the <code class="literal">size</code> and <code class="literal">shard size</code> settings covered in the next section provide tools to help control the accuracy levels.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_parameters_4"></a>Parameters<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_jlh_score"></a>JLH score<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The JLH score can be used as a significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "jlh": {
	 }</pre>
</div>
<p>The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. The <em>absolute</em> change in popularity (foregroundPercent - backgroundPercent) would favor common terms whereas the <em>relative</em> change in popularity (foregroundPercent/ backgroundPercent) would favor rare terms. Rare vs common is essentially a precision vs recall balance and so the absolute and relative changes are multiplied to provide a sweet spot between precision and recall.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_mutual_information"></a>Mutual information<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>Mutual information as described in "Information Retrieval", Manning et al., Chapter 13.5.1 can be used as significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "mutual_information": {
	      "include_negatives": true
	 }</pre>
</div>
<p>Mutual information does not differentiate between terms that are descriptive for the subset or for documents outside the subset. The significant terms therefore can contain terms that appear more or less frequent in the subset than outside the subset. To filter out the terms that appear less often in the subset than in documents outside the subset, <code class="literal">include_negatives</code> can be set to <code class="literal">false</code>.</p>
<p>Per default, the assumption is that the documents in the bucket are also contained in the background. If instead you defined a custom background filter that represents a different set of documents that you want to compare to, set</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"background_is_superset": false</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_chi_square"></a>Chi square<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>Chi square as described in "Information Retrieval", Manning et al., Chapter 13.5.2 can be used as significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "chi_square": {
	 }</pre>
</div>
<p>Chi square behaves like mutual information and can be configured with the same parameters <code class="literal">include_negatives</code> and <code class="literal">background_is_superset</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_google_normalized_distance"></a>Google normalized distance<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>Google normalized distance  as described in "The Google Similarity Distance", Cilibrasi and Vitanyi, 2007 (<a href="http://arxiv.org/pdf/cs/0412098v3.pdf" class="ulink" target="_top">http://arxiv.org/pdf/cs/0412098v3.pdf</a>) can be used as significance score by adding the parameter</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "gnd": {
	 }</pre>
</div>
<p><code class="literal">gnd</code> also accepts the <code class="literal">background_is_superset</code> parameter.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_percentage"></a>Percentage<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>A simple calculation of the number of documents in the foreground sample with a term divided by the number of documents in the background with the term.
By default this produces a score greater than zero and less than one.</p>
<p>The benefit of this heuristic is that the scoring logic is simple to explain to anyone familiar with a "per capita" statistic. However, for fields with high cardinality there is a tendency for this heuristic to select the rarest terms such as typos that occur only once because they score 1/1 = 100%.</p>
<p>It would be hard for a seasoned boxer to win a championship if the prize was awarded purely on the basis of percentage of fights won - by these rules a newcomer with only one fight under their belt would be impossible to beat.
Multiple observations are typically required to reinforce a view so it is recommended in these cases to set both <code class="literal">min_doc_count</code> and <code class="literal">shard_min_doc_count</code> to a higher value such as 10 in order to filter out the low-frequency terms that otherwise take precedence.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	 "percentage": {
	 }</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_which_one_is_best"></a>Which one is best?<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>Roughly, <code class="literal">mutual_information</code> prefers high frequent terms even if they occur also frequently in the background. For example, in an analysis of natural language text this might lead to selection of stop words. <code class="literal">mutual_information</code> is unlikely to select very rare terms like misspellings. <code class="literal">gnd</code> prefers terms with a high co-occurrence and avoids selection of stopwords. It might be better suited for synonym detection. However, <code class="literal">gnd</code> has a tendency to select very rare terms that are, for example, a result of misspelling. <code class="literal">chi_square</code> and <code class="literal">jlh</code> are somewhat in-between.</p>
<p>It is hard to say which one of the different heuristics will be the best choice as it depends on what the significant terms are used for (see for example [Yang and Pedersen, "A Comparative Study on Feature Selection in Text Categorization", 1997](<a href="http://courses.ischool.berkeley.edu/i256/f06/papers/yang97comparative.pdf" class="ulink" target="_top">http://courses.ischool.berkeley.edu/i256/f06/papers/yang97comparative.pdf</a>) for a study on using significant terms for feature selection for text classification).</p>
<p>If none of the above measures suits your usecase than another option is to implement a custom significance measure:</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_scripted"></a>Scripted<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>Customized scores can be implemented via a script:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">	    "script_heuristic": {
              "script": {
	        "lang": "painless",
	        "source": "params._subset_freq/(params._superset_freq - params._subset_freq + 1)"
	      }
            }</pre>
</div>
<p>Scripts can be inline (as in above example), indexed or stored on disk. For details on the options, see <a class="xref" href="modules-scripting.html" title="Scripting">script documentation</a>.</p>
<p>Available parameters in the script are</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col>
<col>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">_subset_freq</code>
</p>
</td>
<td valign="top">
<p>
Number of documents the term appears in the subset.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_superset_freq</code>
</p>
</td>
<td valign="top">
<p>
Number of documents the term appears in the superset.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_subset_size</code>
</p>
</td>
<td valign="top">
<p>
Number of documents in the subset.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_superset_size</code>
</p>
</td>
<td valign="top">
<p>
Number of documents in the superset.
</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="sig-terms-shard-size"></a>Size &amp; Shard Size<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
If the number of unique terms is greater than <code class="literal">size</code>, the returned list can be slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
<p>To ensure better accuracy a multiple of the final <code class="literal">size</code> is used as the number of terms to request from each shard
(<code class="literal">2 * (size * 1.5 + 10)</code>). To take manual control of this setting the <code class="literal">shard_size</code> parameter
can be  used to control the volumes of candidate terms produced by each shard.</p>
<p>Low-frequency terms can turn out to be the most interesting ones once all results are combined so the
significant_terms aggregation can produce higher-quality results when the <code class="literal">shard_size</code> parameter is set to
values significantly higher than the <code class="literal">size</code> setting. This ensures that a bigger volume of promising candidate terms are given
a consolidated review by the reducing node before the final selection. Obviously large candidate term lists
will cause extra network traffic and RAM usage so this is  quality/cost trade off that needs to be balanced.  If <code class="literal">shard_size</code> is set to -1 (the default) then <code class="literal">shard_size</code> will be automatically estimated based on the number of shards and the <code class="literal">size</code> parameter.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> cannot be smaller than <code class="literal">size</code> (as it doesn’t make much sense). When it is, Elasticsearch will
        override it and reset it to be equal to <code class="literal">size</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_minimum_document_count_2"></a>Minimum document count<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>It is possible to only return terms that match more than a configured number of hits using the <code class="literal">min_doc_count</code> option:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "tags" : {
            "significant_terms" : {
                "field" : "tag",
                "min_doc_count": 10
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/514.console"></div>
<p>The above aggregation would only return tags which have been found in 10 hits or more. Default value is <code class="literal">3</code>.</p>
<p>Terms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step. However, the shard does not have the information about the global term frequencies available. The decision if a term is added to a candidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word. The <code class="literal">min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code class="literal">min_doc_count</code>. This might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated the candidate lists. To avoid this, the <code class="literal">shard_size</code> parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.</p>
<p><code class="literal">shard_min_doc_count</code> parameter</p>
<p>The parameter <code class="literal">shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or not with respect to the <code class="literal">min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the <code class="literal">shard_min_doc_count</code>. If your dictionary contains many low frequent words and you are not interested in these (for example misspellings), then you can set the <code class="literal">shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required <code class="literal">min_doc_count</code> even after merging the local frequencies. <code class="literal">shard_min_doc_count</code> is set to <code class="literal">1</code> per default and has no effect unless you explicitly set it.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Setting <code class="literal">min_doc_count</code> to <code class="literal">1</code> is generally not advised as it tends to return terms that
         are typos or other bizarre curiosities. Finding more than one instance of a term helps
         reinforce that, while still rare, the term was not the result of a one-off accident. The
         default value of 3 is used to provide a minimum weight-of-evidence.
         Setting <code class="literal">shard_min_doc_count</code> too high will cause significant candidate terms to be filtered out on a shard level. This value should be set much lower than <code class="literal">min_doc_count/#shards</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_custom_background_context"></a>Custom background context<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The default source of statistical information for background term frequencies is the entire index and this
scope can be narrowed through the use of a <code class="literal">background_filter</code> to focus in on significant terms within a narrower
context:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match" : {
            "city" : "madrid"
        }
    },
    "aggs" : {
        "tags" : {
            "significant_terms" : {
                "field" : "tag",
                "background_filter": {
                	"term" : { "text" : "spain"}
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/515.console"></div>
<p>The above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing
terms like "Spanish" that are unusual in the full index’s worldwide context but commonplace in the subset of documents containing the
word "Spain".</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Use of background filters will slow the query as each term’s postings must be filtered to determine a frequency</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_filtering_values_2"></a>Filtering Values<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>It is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features
described in the <a class="xref" href="search-aggregations-bucket-terms-aggregation.html" title="Terms Aggregation">terms aggregation</a> documentation.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_collect_mode"></a>Collect mode<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>To avoid memory issues, the <code class="literal">significant_terms</code> aggregation always computes child aggregations in <code class="literal">breadth_first</code> mode.
A description of the different collection modes can be found in the
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-collect" title="Collect mode">terms aggregation</a> documentation.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_execution_hint_2"></a>Execution hint<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significantterms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>There are different mechanisms by which terms aggregations can be executed:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
by using field values directly in order to aggregate data per-bucket (<code class="literal">map</code>)
</li>
<li class="listitem">
by using global ordinals of the field and allocating one bucket per global ordinal (<code class="literal">global_ordinals</code>)
</li>
</ul>
</div>
<p>Elasticsearch tries to have sensible defaults so this is something that generally doesn’t need to be configured.</p>
<p><code class="literal">global_ordinals</code> is the default option for <code class="literal">keyword</code> field, it uses global ordinals to allocates buckets dynamically
so memory usage is linear to the number of values of the documents that are part of the aggregation scope.</p>
<p><code class="literal">map</code> should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode
is significantly faster. By default, <code class="literal">map</code> is only used when running an aggregation on scripts, since they don’t have
ordinals.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "tags" : {
             "significant_terms" : {
                 "field" : "tags",
                 "execution_hint": "map" <a id="CO241-1"></a><i class="conum" data-value="1"></i>
             }
         }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/516.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO241-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>the possible values are <code class="literal">map</code>, <code class="literal">global_ordinals</code></p>
</td>
</tr>
</table>
</div>
<p>Please note that Elasticsearch will ignore this execution hint if it is not applicable.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations-bucket-sampler-aggregation.html">« sampler 聚合</a>
</span>
<span class="next">
<a href2="search-aggregations-bucket-significanttext-aggregation.html">Significant Text Aggregation »</a>
</span>
</div>
</div>

                  <!-- end body -->
                        </div>
                        <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                        
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </section>
</div>
<script src="../static/cn.js"></script>
</body>
</html>