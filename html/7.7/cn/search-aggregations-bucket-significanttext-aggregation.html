<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>significant_text 聚合 | ElasticSearch 7.7 权威指南中文版</title>
	<meta name="keywords" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <meta name="description" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
	<link rel="stylesheet" type="text/css" href="../static/styles.css" />
	<script>
	var _link = 'search-aggregations-bucket-significanttext-aggregation.html';
    </script>
</head>
<body>
<div class="main-container">
    <section id="content">
        <div class="content-wrapper">
            <section id="guide" lang="zh_cn">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                            <div style="color:gray; word-break: break-all; font-size:12px;">原英文版地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-bucket-significanttext-aggregation.html" rel="nofollow" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-bucket-significanttext-aggregation.html</a>, 原文档版权归 www.elastic.co 所有<br/>本地英文版地址: <a href="../en/search-aggregations-bucket-significanttext-aggregation.html" rel="nofollow" target="_blank">../en/search-aggregations-bucket-significanttext-aggregation.html</a></div>
                        <!-- start body -->
                  <div class="page_header">
<strong>重要</strong>: 此版本不会发布额外的bug修复或文档更新。最新信息请参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="nofollow">当前版本文档</a>。
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch 权威指南 [7.7]</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations.html">聚合</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations-bucket.html">桶(bucket)聚合</a></span>
»
<span class="breadcrumb-node">significant_text 聚合</span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-bucket-significantterms-aggregation.html">« significant_terms 聚合</a>
</span>
<span class="next">
<a href2="search-aggregations-bucket-terms-aggregation.html">Terms Aggregation »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title">
<a id="search-aggregations-bucket-significanttext-aggregation"></a>重要文本(significant_text)聚合
</h2>
</div></div></div>
<p>
一种聚合，返回集合中有趣或不寻常的自定义文本的聚合。

它类似于<a class="xref" href="search-aggregations-bucket-significantterms-aggregation.html" title="重要词项聚合">significant_terms</a>聚合，但不同之处在于:
</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
它是专门设计用于<code class="literal">text</code>类型的字段的
</li>
<li class="listitem">
它不需要字段数据或文档值
</li>
<li class="listitem">
它可以动态地重新分析文本内容，这意味着它还可以过滤噪音文本的重复部分，否则这些重复部分会影响统计数据。
</li>
</ul>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>
重新分析<em>大</em>结果集将需要大量的时间和内存。

建议将 significant_text 聚合用作 <a class="xref" href="search-aggregations-bucket-sampler-aggregation.html" title="采样器聚合">sampler</a> 或 <a class="xref" href="search-aggregations-bucket-diversified-sampler-aggregation.html" title="多样化取样聚合">diversified_sampler</a> 聚合的子元素，以将分析限制在一小部分最匹配的文档中，例如200个。

这通常会提高速度、内存使用和结果的质量。
</p>
</div>
</div>
<div class="ulist itemizedlist">
<p class="title"><strong>用例示例：</strong></p>
<ul class="itemizedlist">
<li class="listitem">
当用户搜索“禽流感”时，提示“H5N1”以扩展查询
</li>
<li class="listitem">
在自动新闻分类器中使用的与股票代码 $ATI 相关的建议关键字
</li>
</ul>
</div>
<p>
在这些情况下，被选择的单词不仅仅是结果中最流行的词项。

最流行的词往往很无聊(<em>and, of, the, we, I, they</em> …​)。

重要的单词是在<em>前景(foreground)</em>和<em>背景(background)</em>集之间受欢迎程度发生了显著变化的词项。

如果词项“H5N1”仅存在于1000万个文档索引中的5个文档中，但是在构成用户搜索结果的100个文档中的4个中出现，则这是重要的并且可能与他们的搜索非常相关。

频率 5/10,000,000 与 4/100 相比差别很大。
</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_basic_use"></a>基本用法
</h3>
</div></div></div>
<p>在典型的用例中，感兴趣的<em>前景</em>集是对查询的最佳匹配搜索结果的选择，而用于统计比较的<em>背景</em>集则是从中收集结果的一个或多个索引。</p>
<p>示例：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
    "query" : {
        "match" : {"content" : "Bird flu"}
    },
    "aggregations" : {
        "my_sample" : {
            "sampler" : {
                "shard_size" : 100
            },
            "aggregations": {
                "keywords" : {
                    "significant_text" : { "field" : "content" }
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/517.console"></div>
<p>响应：</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
    "aggregations" : {
        "my_sample": {
            "doc_count": 100,
            "keywords" : {
                "doc_count": 100,
                "buckets" : [
                    {
                        "key": "h5n1",
                        "doc_count": 4,
                        "score": 4.71235374214817,
                        "bg_count": 5
                    }
                    ...
                ]
            }
        }
    }
}</pre>
</div>
<p>
结果显示，“h5n1”是与“bird flu”（禽流感）密切相关的几个词项之一。

作为一个整体，它在我们的索引中只出现了5次(见<code class="literal">bg_count</code>)，但其中4次幸运地出现在我们的100份“bird flu”结果样本中。

这表明了它是一个重要的词，用户可以潜在地添加到他们的搜索中去。
</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="filter-duplicate-text-noisy-data"></a>使用<code class="literal">filter_duplicate_text</code>处理噪声数据
</h3>
</div></div></div>
<p>自定义字段通常包含原始内容和文本的机械副本(剪切和粘贴传记、电子邮件回复链、转发、样板页眉/页脚、页面导航菜单、侧栏新闻链接、版权声明、标准免责声明、地址)。</p>
<p>
在真实世界的数据中，如果不过滤掉这些重复的文本部分，它们往往会在<code class="literal">significant_text</code>结果中占据重要位置。

在索引时过滤近似重复的文本是一项困难的任务，但是我们可以使用<code class="literal">filter_duplicate_text</code>设置在查询时即时清理数据。
</p>
<p>
首先，让我们来看一个未经过滤的真实世界的例子，它使用了涵盖各种新闻的一百万篇新闻文章的<a href="http://research.signalmedia.co/newsir16/signal-dataset.html" class="ulink" target="_top">Signal media数据集</a>。

以下是搜索提及“elasticsearch”的文章的原始重要文本结果:
</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    ...
  "aggregations": {
    "sample": {
      "doc_count": 35,
      "keywords": {
        "doc_count": 35,
        "buckets": [
          {
            "key": "elasticsearch",
            "doc_count": 35,
            "score": 28570.428571428572,
            "bg_count": 35
          },
          ...
          {
            "key": "currensee",
            "doc_count": 8,
            "score": 6530.383673469388,
            "bg_count": 8
          },
          ...
          {
            "key": "pozmantier",
            "doc_count": 4,
            "score": 3265.191836734694,
            "bg_count": 4
          },
          ...

}</pre>
</div>
<p>
未清理的文档中出现了一些看起来很奇怪的词，从表面上看，这些词与我们的搜索词“elasticsearch”在统计上是相关的，例如“pozmantier”。

我们可以深入到这些文档的示例中，看看为什么使用以下查询会关联到"pozmantier"：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "simple_query_string": {
      "query": "+elasticsearch  +pozmantier"
    }
  },
  "_source": [
    "title",
    "source"
  ],
  "highlight": {
    "fields": {
      "content": {}
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/518.console"></div>
<p>结果显示了一系列非常相似的新闻文章，内容是关于一些科技项目的评审小组:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  ...
  "hits": {
    "hits": [
      {
        ...
        "_source": {
          "source": "Presentation Master",
          "title": "T.E.N. Announces Nominees for the 2015 ISE® North America Awards"
        },
        "highlight": {
          "content": [
            "City of San Diego Mike &lt;em&gt;Pozmantier&lt;/em&gt;, Program Manager, Cyber Security Division, Department of",
            " Janus, Janus &lt;em&gt;ElasticSearch&lt;/em&gt; Security Visualization Engine "
          ]
        }
      },
      {
        ...
        "_source": {
          "source": "RCL Advisors",
          "title": "T.E.N. Announces Nominees for the 2015 ISE(R) North America Awards"
        },
        "highlight": {
          "content": [
            "Mike &lt;em&gt;Pozmantier&lt;/em&gt;, Program Manager, Cyber Security Division, Department of Homeland Security S&amp;T",
            "Janus, Janus &lt;em&gt;ElasticSearch&lt;/em&gt; Security Visualization Engine"
          ]
        }
      },
      ...</pre>
</div>
<p>Mike Pozmantier是评审团中的众多评委之一，elasticsearch 被用于众多被评的项目中的一个。</p>
<p>通常情况下，这篇冗长的新闻稿会被各种新闻网站剪切和粘贴，因此，它们包含的任何罕见的名称、数字或拼写错误都会在统计上与我们的匹配查询相关。</p>
<p>
幸运的是，相似的文档倾向于相似地排序，因此作为检查最匹配文档流的一部分，significant_text 聚合可以应用过滤器来移除已经看到的任何 6 个或更多个词元(token)的序号。

现在让我们来尝试同样的查询，但是打开<code class="literal">filter_duplicate_text</code>设置：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
  "query": {
    "match": {
      "content": "elasticsearch"
    }
  },
  "aggs": {
    "sample": {
      "sampler": {
        "shard_size": 100
      },
      "aggs": {
        "keywords": {
          "significant_text": {
            "field": "content",
            "filter_duplicate_text": true
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/519.console"></div>
<p>对于任何熟悉 elastic stack 的人来说，分析我们的去重的文本的结果显然质量更高：</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 35,
      "keywords": {
        "doc_count": 35,
        "buckets": [
          {
            "key": "elasticsearch",
            "doc_count": 22,
            "score": 11288.001166180758,
            "bg_count": 35
          },
          {
            "key": "logstash",
            "doc_count": 3,
            "score": 1836.648979591837,
            "bg_count": 4
          },
          {
            "key": "kibana",
            "doc_count": 3,
            "score": 1469.3020408163263,
            "bg_count": 5
          }
        ]
      }
    }
  }
}</pre>
</div>
<p>由于复制粘贴操作或其他形式的机械重复，Pozmantier先生和其他与elasticsearch的一次性关联不再出现在聚合结果中。</p>
<p>
如果你的重复或近似重复的内容可通过单值索引字段(可能是文章的<code class="literal">title</code>文本的哈希或<code class="literal">original_press_release_url</code>字段)来识别，那么使用父<a class="xref" href="search-aggregations-bucket-diversified-sampler-aggregation.html" title="Diversified Sampler Aggregation">diversified_sampler</a>聚合来从基于该单个关键字的样本集中消除这些文档会更有效。

从性能的角度来看，你可以预先提供给 significant_text 聚合的重复内容越少，性能就越好。
</p>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>How are the significance scores calculated?</strong></p>
</div></div></div>
<p>

The numbers returned for scores are primarily intended for ranking different suggestions sensibly rather than something easily understood by end users.

The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets.

In brief, a term is considered significant if there is a noticeable difference in the frequency in which a term appears in the subset and in the background.

The way the terms are ranked can be configured, see "Parameters" section.
</p>
</div>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>Use the <em>"like this but not this"</em> pattern</strong></p>
</div></div></div>
<p>You can spot mis-categorized content by first searching a structured field e.g. <code class="literal">category:adultMovie</code> and use significant_text on the
text "movie_description" field. Take the suggested words (I’ll leave them to your imagination) and then search for all movies NOT marked as category:adultMovie but containing these keywords.
You now have a ranked list of badly-categorized movies that you should reclassify or at least remove from the "familyFriendly" category.</p>
<p>The significance score from each term can also provide a useful <code class="literal">boost</code> setting to sort matches.
Using the <code class="literal">minimum_should_match</code> setting of the <code class="literal">terms</code> query with the keywords will help control the balance of precision/recall in the result set i.e
a high setting would have a small number of relevant results packed full of keywords and a setting of "1" would produce a more exhaustive results set with all documents containing <em>any</em> keyword.</p>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_limitations_6"></a>Limitations<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_no_support_for_child_aggregations"></a>No support for child aggregations<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The significant_text aggregation intentionally does not support the addition of child aggregations because:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
It would come with a high memory cost
</li>
<li class="listitem">
It isn’t a generally useful feature and there is a workaround for those that need it
</li>
</ul>
</div>
<p>The volume of candidate terms is generally very high and these are pruned heavily before the final
results are returned. Supporting child aggregations would generate additional churn and be inefficient.
Clients can always take the heavily-trimmed set of results from a <code class="literal">significant_text</code> request and
make a subsequent follow-up query using a <code class="literal">terms</code> aggregation with an <code class="literal">include</code> clause and child
aggregations to perform further analysis of selected keywords in a more efficient fashion.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_no_support_for_nested_objects"></a>No support for nested objects<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The significant_text aggregation currently also cannot be used with text fields in
nested objects, because it works with the document JSON source. This makes this
feature inefficient when matching nested docs from stored JSON given a matching
Lucene docID.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_approximate_counts_2"></a>Approximate counts<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and
as such may be:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
low if certain shards did not provide figures for a given term in their top sample
</li>
<li class="listitem">
high when considering the background frequency as it may count occurrences found in deleted documents
</li>
</ul>
</div>
<p>Like most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.
However, the <code class="literal">size</code> and <code class="literal">shard size</code> settings covered in the next section provide tools to help control the accuracy levels.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_parameters_5"></a>Parameters<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_significance_heuristics"></a>Significance heuristics<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>This aggregation supports the same scoring heuristics (JLH, mutual_information, gnd, chi_square etc) as the <a class="xref" href="search-aggregations-bucket-significantterms-aggregation.html" title="Significant Terms Aggregation">significant terms</a> aggregation</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="sig-text-shard-size"></a>Size &amp; Shard Size<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The <code class="literal">size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
If the number of unique terms is greater than <code class="literal">size</code>, the returned list can be slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
<p>To ensure better accuracy a multiple of the final <code class="literal">size</code> is used as the number of terms to request from each shard
(<code class="literal">2 * (size * 1.5 + 10)</code>). To take manual control of this setting the <code class="literal">shard_size</code> parameter
can be  used to control the volumes of candidate terms produced by each shard.</p>
<p>Low-frequency terms can turn out to be the most interesting ones once all results are combined so the
significant_terms aggregation can produce higher-quality results when the <code class="literal">shard_size</code> parameter is set to
values significantly higher than the <code class="literal">size</code> setting. This ensures that a bigger volume of promising candidate terms are given
a consolidated review by the reducing node before the final selection. Obviously large candidate term lists
will cause extra network traffic and RAM usage so this is  quality/cost trade off that needs to be balanced.  If <code class="literal">shard_size</code> is set to -1 (the default) then <code class="literal">shard_size</code> will be automatically estimated based on the number of shards and the <code class="literal">size</code> parameter.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> cannot be smaller than <code class="literal">size</code> (as it doesn’t make much sense). When it is, elasticsearch will
        override it and reset it to be equal to <code class="literal">size</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_minimum_document_count_3"></a>Minimum document count<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>It is possible to only return terms that match more than a configured number of hits using the <code class="literal">min_doc_count</code> option.
The Default value is 3.</p>
<p>Terms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step.
However, the shard does not have the information about the global term frequencies available. The decision if a term is added to a
candidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word.
The <code class="literal">min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the
term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code class="literal">min_doc_count</code>.
This might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated
the candidate lists. To avoid this, the <code class="literal">shard_size</code> parameter can be increased to allow more candidate terms on the shards.
However, this increases memory consumption and network traffic.</p>
<p><code class="literal">shard_min_doc_count</code> parameter</p>
<p>The parameter <code class="literal">shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or
not with respect to the <code class="literal">min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the
<code class="literal">shard_min_doc_count</code>. If your dictionary contains many low frequent words and you are not interested in these (for example misspellings),
then you can set the <code class="literal">shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty
not reach the required <code class="literal">min_doc_count</code> even after merging the local frequencies. <code class="literal">shard_min_doc_count</code> is set to <code class="literal">1</code> per default and has
no effect unless you explicitly set it.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Setting <code class="literal">min_doc_count</code> to <code class="literal">1</code> is generally not advised as it tends to return terms that
         are typos or other bizarre curiosities. Finding more than one instance of a term helps
         reinforce that, while still rare, the term was not the result of a one-off accident. The
         default value of 3 is used to provide a minimum weight-of-evidence.
         Setting <code class="literal">shard_min_doc_count</code> too high will cause significant candidate terms to be filtered out on a shard level.
         This value should be set much lower than <code class="literal">min_doc_count/#shards</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_custom_background_context_2"></a>Custom background context<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>The default source of statistical information for background term frequencies is the entire index and this
scope can be narrowed through the use of a <code class="literal">background_filter</code> to focus in on significant terms within a narrower
context:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
    "query" : {
        "match" : {
            "content" : "madrid"
        }
    },
    "aggs" : {
        "tags" : {
            "significant_text" : {
                "field" : "content",
                "background_filter": {
                    "term" : { "content" : "spain"}
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/520.console"></div>
<p>The above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing
terms like "Spanish" that are unusual in the full index’s worldwide context but commonplace in the subset of documents containing the
word "Spain".</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Use of background filters will slow the query as each term’s postings must be filtered to determine a frequency</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_dealing_with_source_and_index_mappings"></a>Dealing with source and index mappings<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>Ordinarily the indexed field name and the original JSON field being retrieved share the same name.
However with more complex field mappings using features like <code class="literal">copy_to</code> the source
JSON field(s) and the indexed field being aggregated can differ.
In these cases it is possible to list the JSON _source fields from which text
will be analyzed using the <code class="literal">source_fields</code> parameter:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET news/_search
{
    "query" : {
        "match" : {
            "custom_all" : "elasticsearch"
        }
    },
    "aggs" : {
        "tags" : {
            "significant_text" : {
                "field" : "custom_all",
                "source_fields": ["content" , "title"]
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/521.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_filtering_values_3"></a>Filtering Values<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/significanttext-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>It is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features
described in the <a class="xref" href="search-aggregations-bucket-terms-aggregation.html" title="Terms Aggregation">terms aggregation</a> documentation.</p>
</div>

</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations-bucket-significantterms-aggregation.html">« significant_terms 聚合</a>
</span>
<span class="next">
<a href2="search-aggregations-bucket-terms-aggregation.html">Terms Aggregation »</a>
</span>
</div>
</div>

                  <!-- end body -->
                        </div>
                        <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                        
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </section>
</div>
<script src="../static/cn.js"></script>
</body>
</html>