<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>terms 聚合 | ElasticSearch 7.7 权威指南中文版</title>
	<meta name="keywords" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <meta name="description" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
	<link rel="stylesheet" type="text/css" href="../static/styles.css" />
	<script>
	var _link = 'search-aggregations-bucket-terms-aggregation.html';
    </script>
</head>
<body>
<div class="main-container">
    <section id="content">
        <div class="content-wrapper">
            <section id="guide" lang="zh_cn">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                            <div style="color:gray; word-break: break-all; font-size:12px;">原英文版地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-bucket-terms-aggregation.html" rel="nofollow" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-bucket-terms-aggregation.html</a>, 原文档版权归 www.elastic.co 所有<br/>本地英文版地址: <a href="../en/search-aggregations-bucket-terms-aggregation.html" rel="nofollow" target="_blank">../en/search-aggregations-bucket-terms-aggregation.html</a></div>
                        <!-- start body -->
                  <div class="page_header">
<strong>重要</strong>: 此版本不会发布额外的bug修复或文档更新。最新信息请参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="nofollow">当前版本文档</a>。
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch 权威指南 [7.7]</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations.html">聚合</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations-bucket.html">桶(bucket)聚合</a></span>
»
<span class="breadcrumb-node">terms 聚合</span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-bucket-significanttext-aggregation.html">« significant_text 聚合</a>
</span>
<span class="next">
<a href2="search-aggregations-bucket-range-field-note.html">Subtleties of bucketing range fields »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title">
<a id="search-aggregations-bucket-terms-aggregation"></a>词项(terms)聚合
</h2>
</div></div></div>
<p>一种基于多桶值源的聚合，其中桶是用一个个的唯一值动态构建的。</p>
<p>示例：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "genres" : {
            "terms" : { "field" : "genre" } <a id="CO242-1"></a><i class="conum" data-value="1"></i>
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/522.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO242-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>
<code class="literal">terms</code>聚合应该是<code class="literal">keyword</code>类型的字段或任何其他适合于桶聚合的数据类型。

为了与<code class="literal">text</code>一起使用，需要启用<a class="xref" href="fielddata.html" title="fielddata" rel="nofollow">fielddata</a>。
</p>
</td>
</tr>
</table>
</div>
<p>响应：</p>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
    ...
    "aggregations" : {
        "genres" : {
            "doc_count_error_upper_bound": 0, <a id="CO243-1"></a><i class="conum" data-value="1"></i>
            "sum_other_doc_count": 0, <a id="CO243-2"></a><i class="conum" data-value="2"></i>
            "buckets" : [ <a id="CO243-3"></a><i class="conum" data-value="3"></i>
                {
                    "key" : "electronic",
                    "doc_count" : 6
                },
                {
                    "key" : "rock",
                    "doc_count" : 3
                },
                {
                    "key" : "jazz",
                    "doc_count" : 2
                }
            ]
        }
    }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO243-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>每个词项的文档计数的误差上限，见<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-approximate-counts" title="Document counts are approximate">下文</a>
</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO243-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>当有很多唯一的词时，Elasticsearch只返回前面几个词；此数字是不属于响应的所有桶的文档计数总和</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO243-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>前几个(top)桶的列表，<code class="literal">top</code>是由<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-order" title="Order">order</a>定义的</p>
</td>
</tr>
</table>
</div>
<p>
默认情况下，<code class="literal">terms</code>聚合将返回按<code class="literal">doc_count</code>排序的前10个词的桶。

可以通过设置参数<code class="literal">size</code>来改变这种默认行为。
</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="search-aggregations-bucket-terms-aggregation-size"></a>size
</h3>
</div></div></div>
<p>
参数<code class="literal">size</code>可以用来定义应该从整个词项列表中返回多少个词项桶。

默认情况下，协调搜索过程的节点(被称为协调节点)将请求每个分片提供其自己的前<code class="literal">size</code>个词项桶，并且一旦所有分片做出响应，它将把结果缩小到最终列表，然后将该列表返回给客户端。

这意味着，如果唯一词的数量大于<code class="literal">size</code>，则返回的列表会稍有偏差且不准确(可能是词项计数稍有偏差，甚至可能是本应该在前 size 个桶中的项没有返回)。
</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>
如果你想要检索嵌套<code class="literal">terms</code>聚合中的<span class="strong strong"><strong>所有</strong></span>词项或所有词项组合，应该使用<a class="xref" href="search-aggregations-bucket-composite-aggregation.html" title="composite聚合">composite</a>聚合，它允许对所有可能的词项进行分页，而不是将size设置为大于<code class="literal">terms</code>聚合中字段的基数。

<code class="literal">terms</code>聚合旨在返回<code class="literal">top</code>(前几个)词项，不允许分页。
</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="search-aggregations-bucket-terms-aggregation-approximate-counts"></a>文档计数是近似值
</h3>
</div></div></div>
<p>
terms 聚合中的文档计数(以及任何子聚合的结果)并不总是准确的。

每一个分片都提供了自己的 terms 排序列表视图。

这些视图被组合起来以给出最终视图。
</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_shard_size_3"></a>分片大小(shard_size)
</h3>
</div></div></div>
<p>请求的<code class="literal">size</code>越高，结果就越准确，但是计算最终结果的成本也就越高(这是因为在分片级别上管理的优先级队列越大，以及节点和客户端之间传输的数据越多)。</p>
<p>
参数<code class="literal">shard_size</code>可用于最小化因请求的<code class="literal">size</code>较大而带来的额外工作。

一旦定义了，它将决定协调节点将从每个分片请求多少个词项。

一旦所有的分片都作出响应，协调节点就会将它们缩小到基于参数<code class="literal">size</code>的最终结果——通过这种方式，可以提高返回项的准确性，并避免将一个大的桶列表流回客户端的开销。
</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> 不能小于<code class="literal">size</code>(因为没有太大意义)。当它存在时，Elasticsearch将覆盖它并将其重置为与<code class="literal">size</code>相等。</p>
</div>
</div>
<p><code class="literal">shard_size</code> 的默认值为 <code class="literal">(size * 1.5 + 10)</code>。</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_calculating_document_count_error"></a>当计算文档数量有误差时
</h3>
</div></div></div>
<p>
在 terms 聚合中可以显示两个误差值。

第一个给出了聚合的整体值，该值表示没有进入最终词项列表的词项的最大潜在文档数。

它被计算为从每个分片返回的最后一个词项的文档计数的总和。
</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_per_bucket_document_count_error"></a>单个桶的文档数量计算有误差
</h3>
</div></div></div>
<p>通过将<code class="literal">show_term_doc_count_error</code>参数设置为true，可以启用第二个误差值：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "products" : {
            "terms" : {
                "field" : "product",
                "size" : 5,
                "show_term_doc_count_error": true
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/523.console"></div>
<p>
这显示了聚合返回的每个词项的误差值，它代表了文档计数中<em>最差情况</em>的误差，在决定<code class="literal">shard_size</code>参数的值时非常有用。

这是通过对没有返回词项的所有分片返回的最后一个词项的文档计数求和来计算的。
</p>
<p>
只有当词项按文档计数降序排列时，才能以这种方式计算这些误差。

当聚合按词项值本身排序(升序或降序)时，在文档计数中没有误差，因为如果一个分片没有返回出现在另一个分片的结果中的特定词项，则它的索引中一定没有该词项。

当聚合按子聚合或按文档计数升序排序时，无法确定文档计数中的误差，并给定一个值 -1 来表示这一点。
</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="search-aggregations-bucket-terms-aggregation-order"></a>排序(order)

</h3>
</div></div></div>
<p>
可以通过设置参数<code class="literal">order</code>来指定桶的顺序。

默认情况下，桶按照<code class="literal">doc_count</code>降序排列。

有可能改变这种行为，如下所示：
</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>
不鼓励使用<code class="literal">_count</code>升序或子查询进行排序，因为这会增加文档计数的<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-approximate-counts" title="Document counts are approximate">误差</a>。

当查询单个分片时，或者当被聚集的字段在索引时被用作路由键时，这是没有问题的:在这些情况下，结果将是准确的，因为分片具有不相交的值。

然而，除此之外，误差是没有上限的。

仍然有用的一种特殊情况是按<a class="xref" href="search-aggregations-metrics-min-aggregation.html" title="min 聚合"><code class="literal">min</code></a>或<a class="xref" href="search-aggregations-metrics-max-aggregation.html" title="max 聚合"><code class="literal">max</code></a>聚合排序：计数不准确，但至少会正确选择最前面的几个桶。
</p>
</div>
</div>
<p>将桶按文档的<code class="literal">_count</code>升序排序：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "genres" : {
            "terms" : {
                "field" : "genre",
                "order" : { "_count" : "asc" }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/524.console"></div>
<p>将桶按按词项的字母顺序的升序排序：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "genres" : {
            "terms" : {
                "field" : "genre",
                "order" : { "_key" : "asc" }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/525.console"></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<h3>在6.0.0版本中废弃</h3>
<p>使用<code class="literal">_key</code>代替<code class="literal">_term</code>，将桶按词项排序</p>
</div>
</div>
<p>按单值指标子聚合对桶进行排序(由聚合名称标识)：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "genres" : {
            "terms" : {
                "field" : "genre",
                "order" : { "max_play_count" : "desc" }
            },
            "aggs" : {
                "max_play_count" : { "max" : { "field" : "play_count" } }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/526.console"></div>
<p>按多值指标子聚集对桶进行排序(由聚合名称标识)：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "genres" : {
            "terms" : {
                "field" : "genre",
                "order" : { "playback_stats.max" : "desc" }
            },
            "aggs" : {
                "playback_stats" : { "stats" : { "field" : "play_count" } }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/527.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<h3>管道(pipeline)聚合不能用于排序</h3>
<p>
<a class="xref" href="search-aggregations-pipeline.html" title="Pipeline Aggregations">管道(pipeline)聚合</a>在所有其他聚合完成后的压缩阶段运行。

因此，它们不能用于排序。
</p>
</div>
</div>
<p>
还可以根据层次结构中“更深”的聚合对桶进行排序。

只要聚合路径是单桶类型，就支持这一点，其中路径中的最后一个聚合可以是单桶聚合，也可以是度量聚合。

如果是单桶类型，则顺序将由桶中的文档数(即<code class="literal">doc_count</code>)来定义，如果是指标类型，则应用与上述相同的规则(如果是多值指标聚合，则路径必须指示要排序的指标名称，如果是单值指标聚合，则排序将应用于该值)。
</p>
<p>路径必须按以下形式定义：</p>
<div class="pre_wrapper lang-ebnf">
<pre class="programlisting prettyprint lang-ebnf">AGG_SEPARATOR       =  '&gt;' ;
METRIC_SEPARATOR    =  '.' ;
AGG_NAME            =  &lt;the name of the aggregation&gt; ;
METRIC              =  &lt;the name of the metric (in case of multi-value metrics aggregation)&gt; ;
PATH                =  &lt;AGG_NAME&gt; [ &lt;AGG_SEPARATOR&gt;, &lt;AGG_NAME&gt; ]* [ &lt;METRIC_SEPARATOR&gt;, &lt;METRIC&gt; ] ;</pre>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "countries" : {
            "terms" : {
                "field" : "artist.country",
                "order" : { "rock&gt;playback_stats.avg" : "desc" }
            },
            "aggs" : {
                "rock" : {
                    "filter" : { "term" : { "genre" :  "rock" }},
                    "aggs" : {
                        "playback_stats" : { "stats" : { "field" : "play_count" }}
                    }
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/528.console"></div>
<p>上面的查询将根据摇滚歌曲的平均播放次数对 艺术家的国家(artist.country) 进行分类。</p>
<p>通过提供一组排序标准，可以使用多个标准来对桶进行排序，如下所示：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "countries" : {
            "terms" : {
                "field" : "artist.country",
                "order" : [ { "rock&gt;playback_stats.avg" : "desc" }, { "_count" : "desc" } ]
            },
            "aggs" : {
                "rock" : {
                    "filter" : { "term" : { "genre" : "rock" }},
                    "aggs" : {
                        "playback_stats" : { "stats" : { "field" : "play_count" }}
                    }
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/529.console"></div>
<p>
上面的查询将根据摇滚歌曲的 平均播放次数(playback_stats.avg)，然后按照<code class="literal">doc_count</code>降序排列 艺术家的国家(artist.country) 类别。
</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>如果两个桶在所有排序标准中共享相同的值，则将再按桶的词项值升序排序，以防止桶的不确定性排序。</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_minimum_document_count_4"></a>最小文档数量
</h3>
</div></div></div>
<p>使用<code class="literal">min_doc_count</code>选项可以只返回匹配超过配置的命中数的词项：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "tags" : {
            "terms" : {
                "field" : "tags",
                "min_doc_count": 10
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/530.console"></div>
<p>上述聚集将仅返回有10次或更多次命中出现的 tags。默认值为<code class="literal">1</code>。</p>
<p>
词项在分片级别上被收集和排序，并在第二步中与从其他分片收集的词项合并。

然而，分片没有关于可用的全局词项计数的信息。

是否将一个词项添加到候选列表的决定只取决于使用局部分片频率在分片上计算的排序。

<code class="literal">min_doc_count</code>标准仅在合并所有分片的本地词项统计之后应用。

在某种程度上，在没有非常<em>确定</em>该词项是否将实际达到所需的<code class="literal">min_doc_count</code>的情况下，就做出了将该词项添加为候选项的决定。

如果低频的词项填充了候选列表，这可能导致许多(全局)高频的词项在最终结果中丢失。

为了避免这种情况，可以增加<code class="literal">shard_size</code>参数，以允许分片上有更多的候选项。

但是，这会增加内存消耗和网络流量。
</p>
<p>参数<code class="literal">shard_min_doc_count</code></p>
<p>
参数<code class="literal">shard_min_doc_count</code>规定了一个分片相对于<code class="literal">min_doc_count</code>是否应该被实际添加到候选列表中的<em>确定性</em>。

只有当词项在集合中的本地分片频率高于<code class="literal">shard_min_doc_count</code>时，才会考虑这些词项。

如果你的字典包含许多低频的单词，而你对这些单词不感兴趣(例如拼写错误)，那么你可以设置<code class="literal">shard_min_doc_count</code>参数来过滤掉分级别上的候选词，即使在合并本地频率之后，这些候选词也肯定不会达到所需的<code class="literal">min_doc_count</code>。 

默认情况下，<code class="literal">shard_min_doc_count</code>设置为<code class="literal">0</code>，除非你显式设置它，否则它不起作用。
</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>
设置<code class="literal">min_doc_count</code>=<code class="literal">0</code>也还是会返回不匹配任何匹配项的桶。

但是，某些返回的文档计数为零的词项可能只属于已删除的文档或其他类型的文档，因此不能保证<code class="literal">match_all</code>查询会为这些词项找到正的文档计数。
</p>
</div>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>
当不对<code class="literal">doc_count</code>进行降序排序时，<code class="literal">min_doc_count</code>的高值可能会返回小于<code class="literal">size</code>的桶数，因为没有从分片中收集足够的数据。

将<code class="literal">shard_min_doc_count</code>设置得太高会导致词项在分片级别被过滤掉。

该值应设置为远低于<code class="literal">min_doc_count/#shards</code>。
</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="search-aggregations-bucket-terms-aggregation-script"></a>脚本
</h3>
</div></div></div>
<p>使用脚本生成一个词：</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "genres" : {
            "terms" : {
                "script" : {
                    "source": "doc['genre'].value",
                    "lang": "painless"
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/531.console"></div>
<p>This will interpret the <code class="literal">script</code> parameter as an <code class="literal">inline</code> script with the default script language and no script parameters. To use a stored script use the following syntax:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "genres" : {
            "terms" : {
                "script" : {
                    "id": "my_script",
                    "params": {
                        "field": "genre"
                    }
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/532.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_value_script_9"></a>Value Script<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "genres" : {
            "terms" : {
                "field" : "genre",
                "script" : {
                    "source" : "'Genre: ' +_value",
                    "lang" : "painless"
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/533.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_filtering_values_4"></a>Filtering Values<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>It is possible to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on regular expression strings or arrays of exact values. Additionally,
<code class="literal">include</code> clauses can filter using <code class="literal">partition</code> expressions.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_filtering_values_with_regular_expressions_2"></a>Filtering Values with regular expressions<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "tags" : {
            "terms" : {
                "field" : "tags",
                "include" : ".*sport.*",
                "exclude" : "water_.*"
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/534.console"></div>
<p>In the above example, buckets will be created for all the tags that has the word <code class="literal">sport</code> in them, except those starting
with <code class="literal">water_</code> (so the tag <code class="literal">water_sports</code> will not be aggregated). The <code class="literal">include</code> regular expression will determine what
values are "allowed" to be aggregated, while the <code class="literal">exclude</code> determines the values that should not be aggregated. When
both are defined, the <code class="literal">exclude</code> has precedence, meaning, the <code class="literal">include</code> is evaluated first and only then the <code class="literal">exclude</code>.</p>
<p>The syntax is the same as <a class="xref" href="regexp-syntax.html" title="Regular expression syntax">regexp queries</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_filtering_values_with_exact_values_2"></a>Filtering Values with exact values<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>For matching based on exact values the <code class="literal">include</code> and <code class="literal">exclude</code> parameters can simply take an array of
strings that represent the terms as they are found in the index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "JapaneseCars" : {
             "terms" : {
                 "field" : "make",
                 "include" : ["mazda", "honda"]
             }
         },
        "ActiveCarManufacturers" : {
             "terms" : {
                 "field" : "make",
                 "exclude" : ["rover", "jensen"]
             }
         }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/535.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title">
<a id="_filtering_values_with_partitions"></a>Filtering Values with partitions<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h4>
</div></div></div>
<p>Sometimes there are too many unique terms to process in a single request/response pair so
it can be useful to break the analysis up into multiple requests.
This can be achieved by grouping the field’s values into a number of partitions at query-time and processing
only one partition in each request.
Consider this request which is looking for accounts that have not logged any access recently:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
   "size": 0,
   "aggs": {
      "expired_sessions": {
         "terms": {
            "field": "account_id",
            "include": {
               "partition": 0,
               "num_partitions": 20
            },
            "size": 10000,
            "order": {
               "last_access": "asc"
            }
         },
         "aggs": {
            "last_access": {
               "max": {
                  "field": "access_date"
               }
            }
         }
      }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/536.console"></div>
<p>This request is finding the last logged access date for a subset of customer accounts because we
might want to expire some customer accounts who haven’t been seen for a long while.
The <code class="literal">num_partitions</code> setting has requested that the unique account_ids are organized evenly into twenty
partitions (0 to 19). and the <code class="literal">partition</code> setting in this request filters to only consider account_ids falling
into partition 0. Subsequent requests should ask for partitions 1 then 2 etc to complete the expired-account analysis.</p>
<p>Note that the <code class="literal">size</code> setting for the number of results returned needs to be tuned with the <code class="literal">num_partitions</code>.
For this particular account-expiration example the process for balancing values for <code class="literal">size</code> and <code class="literal">num_partitions</code> would be as follows:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Use the <code class="literal">cardinality</code> aggregation to estimate the total number of unique account_id values
</li>
<li class="listitem">
Pick a value for <code class="literal">num_partitions</code> to break the number from 1) up into more manageable chunks
</li>
<li class="listitem">
Pick a <code class="literal">size</code> value for the number of responses we want from each partition
</li>
<li class="listitem">
Run a test request
</li>
</ol>
</div>
<p>If we have a circuit-breaker error we are trying to do too much in one request and must increase <code class="literal">num_partitions</code>.
If the request was successful but the last account ID in the date-sorted test response was still an account we might want to
expire then we may be missing accounts of interest and have set our numbers too low. We must either</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
increase the <code class="literal">size</code> parameter to return more results per partition (could be heavy on memory) or
</li>
<li class="listitem">
increase the <code class="literal">num_partitions</code> to consider less accounts per request (could increase overall processing time as we need to make more requests)
</li>
</ul>
</div>
<p>Ultimately this is a balancing act between managing the Elasticsearch resources required to process a single request and the volume
of requests that the client application must issue to complete a task.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_multi_field_terms_aggregation"></a>Multi-field terms aggregation<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>The <code class="literal">terms</code> aggregation does not support collecting terms from multiple fields
in the same document.  The reason is that the <code class="literal">terms</code> agg doesn’t collect the
string term values themselves, but rather uses
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-execution-hint" title="Execution hint">global ordinals</a>
to produce a list of all of the unique values in the field.  Global ordinals
results in an important performance boost which would not be possible across
multiple fields.</p>
<p>There are two approaches that you can use to perform a <code class="literal">terms</code> agg across
multiple fields:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-script" title="Script">Script</a>
</span>
</dt>
<dd>
Use a script to retrieve terms from multiple fields.  This disables the global
ordinals optimization and will be slower than collecting terms from a single
field, but it gives you the flexibility to implement this option at search
time.
</dd>
<dt>
<span class="term">
<a class="xref" href="copy-to.html" title="copy_to"><code class="literal">copy_to</code> field</a>
</span>
</dt>
<dd>
If you know ahead of time that you want to collect the terms from two or more
fields, then use <code class="literal">copy_to</code> in your mapping to create a new dedicated field at
index time which contains the values from both fields.  You can aggregate on
this single field, which will benefit from the global ordinals optimization.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="search-aggregations-bucket-terms-aggregation-collect"></a>Collect mode<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>Deferring calculation of child aggregations</p>
<p>For fields with many unique terms and a small number of required results it can be more efficient to delay the calculation
of child aggregations until the top parent-level aggs have been pruned. Ordinarily, all branches of the aggregation tree
are expanded in one depth-first pass and only then any pruning occurs.
In some scenarios this can be very wasteful and can hit memory constraints.
An example problem scenario is querying a movie database for the 10 most popular actors and their 5 most common co-stars:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "actors" : {
             "terms" : {
                 "field" : "actors",
                 "size" : 10
             },
            "aggs" : {
                "costars" : {
                     "terms" : {
                         "field" : "actors",
                         "size" : 5
                     }
                 }
            }
         }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/537.console"></div>
<p>Even though the number of actors may be comparatively small and we want only 50 result buckets there is a combinatorial explosion of buckets
during calculation - a single actor can produce n² buckets where n is the number of actors. The sane option would be to first determine
the 10 most popular actors and only then examine the top co-stars for these 10 actors. This alternative strategy is what we call the <code class="literal">breadth_first</code> collection
mode as opposed to the <code class="literal">depth_first</code> mode.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">breadth_first</code> is the default mode for fields with a cardinality bigger than the requested size or when the cardinality is unknown (numeric fields or scripts for instance).
It is possible to override the default heuristic and to provide a collect mode directly in the request:</p>
</div>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "actors" : {
             "terms" : {
                 "field" : "actors",
                 "size" : 10,
                 "collect_mode" : "breadth_first" <a id="CO244-1"></a><i class="conum" data-value="1"></i>
             },
            "aggs" : {
                "costars" : {
                     "terms" : {
                         "field" : "actors",
                         "size" : 5
                     }
                 }
            }
         }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/538.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO244-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>the possible values are <code class="literal">breadth_first</code> and <code class="literal">depth_first</code></p>
</td>
</tr>
</table>
</div>
<p>When using <code class="literal">breadth_first</code> mode the set of documents that fall into the uppermost buckets are
cached for subsequent replay so there is a memory overhead in doing this which is linear with the number of matching documents.
Note that the <code class="literal">order</code> parameter can still be used to refer to data from a child aggregation when using the <code class="literal">breadth_first</code> setting - the parent
aggregation understands that this child aggregation will need to be called first before any of the other child aggregations.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Nested aggregations such as <code class="literal">top_hits</code> which require access to score information under an aggregation that uses the <code class="literal">breadth_first</code>
collection mode need to replay the query on the second pass but only for the documents belonging to the top buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="search-aggregations-bucket-terms-aggregation-execution-hint"></a>Execution hint<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>There are different mechanisms by which terms aggregations can be executed:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
by using field values directly in order to aggregate data per-bucket (<code class="literal">map</code>)
</li>
<li class="listitem">
by using global ordinals of the field and allocating one bucket per global ordinal (<code class="literal">global_ordinals</code>)
</li>
</ul>
</div>
<p>Elasticsearch tries to have sensible defaults so this is something that generally doesn’t need to be configured.</p>
<p><code class="literal">global_ordinals</code> is the default option for <code class="literal">keyword</code> field, it uses global ordinals to allocates buckets dynamically
so memory usage is linear to the number of values of the documents that are part of the aggregation scope.</p>
<p><code class="literal">map</code> should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode
is significantly faster. By default, <code class="literal">map</code> is only used when running an aggregation on scripts, since they don’t have
ordinals.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "tags" : {
             "terms" : {
                 "field" : "tags",
                 "execution_hint": "map" <a id="CO245-1"></a><i class="conum" data-value="1"></i>
             }
         }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/539.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO245-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The possible values are <code class="literal">map</code>, <code class="literal">global_ordinals</code></p>
</td>
</tr>
</table>
</div>
<p>Please note that Elasticsearch will ignore this execution hint if it is not applicable and that there is no backward compatibility guarantee on these hints.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_missing_value_17"></a>Missing value<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "aggs" : {
        "tags" : {
             "terms" : {
                 "field" : "tags",
                 "missing": "N/A" <a id="CO246-1"></a><i class="conum" data-value="1"></i>
             }
         }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/540.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO246-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">tags</code> field will fall into the same bucket as documents that have the value <code class="literal">N/A</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title">
<a id="_mixing_field_types"></a>Mixing field types<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a>
</h3>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When aggregating on multiple indices the type of the aggregated field may not be the same in all indices.
Some types are compatible with each other (<code class="literal">integer</code> and <code class="literal">long</code> or <code class="literal">float</code> and <code class="literal">double</code>) but when the types are a mix
of decimal and non-decimal number the terms aggregation will promote the non-decimal numbers to decimal numbers.
This can result in a loss of precision in the bucket values.</p>
</div>
</div>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations-bucket-significanttext-aggregation.html">« significant_text 聚合</a>
</span>
<span class="next">
<a href2="search-aggregations-bucket-range-field-note.html">Subtleties of bucketing range fields »</a>
</span>
</div>
</div>

                  <!-- end body -->
                        </div>
                        <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                        
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </section>
</div>
<script src="../static/cn.js"></script>
</body>
</html>