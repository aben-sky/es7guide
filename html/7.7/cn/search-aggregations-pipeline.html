<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>管道(pipeline)聚合 | ElasticSearch 7.7 权威指南中文版</title>
	<meta name="keywords" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <meta name="description" content="ElasticSearch 权威指南中文版, elasticsearch 7, es7, 实时数据分析，实时数据检索" />
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
	<link rel="stylesheet" type="text/css" href="../static/styles.css" />
	<script>
	var _link = 'search-aggregations-pipeline.html';
    </script>
</head>
<body>
<div class="main-container">
    <section id="content">
        <div class="content-wrapper">
            <section id="guide" lang="zh_cn">
                <div class="container">
                    <div class="row">
                        <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                            <div style="color:gray; word-break: break-all; font-size:12px;">原英文版地址: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-pipeline.html" rel="nofollow" target="_blank">https://www.elastic.co/guide/en/elasticsearch/reference/7.7/search-aggregations-pipeline.html</a>, 原文档版权归 www.elastic.co 所有<br/>本地英文版地址: <a href="../en/search-aggregations-pipeline.html" rel="nofollow" target="_blank">../en/search-aggregations-pipeline.html</a></div>
                        <!-- start body -->
                  <div class="page_header">
<strong>重要</strong>: 此版本不会发布额外的bug修复或文档更新。最新信息请参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="nofollow">当前版本文档</a>。
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch 权威指南 [7.7]</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations.html">聚合</a></span>
»
<span class="breadcrumb-node">管道(pipeline)聚合</span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-bucket-range-field-note.html">« 给范围字段分桶的微妙之处</a>
</span>
<span class="next">
<a href2="search-aggregations-pipeline-bucket-script-aggregation.html">Bucket Script Aggregation »</a>
</span>
</div>
<div class="chapter">
<div class="titlepage"><div><div>
<h2 class="title">
<a id="search-aggregations-pipeline"></a>管道(pipeline)聚合
</h2>
</div></div></div>
<p>
管道聚合处理其他聚合(而不是文档集)产生的输出，将信息添加到输出树中。 

管道聚合有很多不同的类型，每一种都计算来自其他聚合的不同信息，但这些类型可以分为两类：
</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<em>Parent</em>
</span>
</dt>
<dd>
一系列管道聚合，提供其父聚合的输出，并能够计算新桶或新聚合以添加到现有桶。 
</dd>
<dt>
<span class="term">
<em>Sibling</em>
</span>
</dt>
<dd>
与同级聚合的输出提供的管道聚合，并且能够计算与同级聚合同级别的新聚合。
</dd>
</dl>
</div>
<p>
管道聚合可以引用执行计算所需的聚合，方法是使用<code class="literal">buckets_path</code>参数来指示所需度量的路径。

定义这些路径的语法可以在下面的<a class="xref" href="search-aggregations-pipeline.html#buckets-path-syntax" title="buckets_path Syntax"><code class="literal">buckets_path</code>语法</a>部分找到。
</p>
<p>
管道聚合不能有子聚合，但是根据类型，它可以引用<code class="literal">buckets_path</code>中的另一个管道，从而允许将管道聚合链接起来。
</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>因为管道聚合只会添加到输出中，所以在链接管道聚合时，每个管道聚合的输出都将包括在最终输出中。</p>
</div>
</div>
<h3>
<a id="buckets-path-syntax"></a><code class="literal">buckets_path</code>语法
</h3>
<p>
大多数管道聚合需要另一个聚合作为其输入。

输入聚合是通过参数<code class="literal">buckets_path</code>定义的，它遵循特定的格式：
</p>
<div class="pre_wrapper lang-ebnf">
<pre class="programlisting prettyprint lang-ebnf">AGG_SEPARATOR       =  `&gt;` ;
METRIC_SEPARATOR    =  `.` ;
AGG_NAME            =  &lt;the name of the aggregation&gt; ;
METRIC              =  &lt;the name of the metric (in case of multi-value metrics aggregation)&gt; ;
MULTIBUCKET_KEY     =  `[&lt;KEY_NAME&gt;]`
PATH                =  &lt;AGG_NAME&gt;&lt;MULTIBUCKET_KEY&gt;? (&lt;AGG_SEPARATOR&gt;, &lt;AGG_NAME&gt; )* ( &lt;METRIC_SEPARATOR&gt;, &lt;METRIC&gt; ) ;</pre>
</div>
<p>
例如，路径<code class="literal">"my_bucket&gt;my_stats.avg"</code>将指向<code class="literal">"my_stats"</code>指标中的<code class="literal">avg</code>值，该值包含在<code class="literal">"my_bucket"</code>桶聚合中。
</p>
<p>
路径相对于管道聚合位置; 它们不是绝对路径，并且路径不能回到聚合树的“上面”。

例如，下面这个查询将移动平均值嵌入在 date_histogram（日期直方图）中，并引用“Sibling”(同级)指标<code class="literal">"the_sum"</code>：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /_search
{
    "aggs": {
        "my_date_histo":{
            "date_histogram":{
                "field":"timestamp",
                "calendar_interval":"day"
            },
            "aggs":{
                "the_sum":{
                    "sum":{ "field": "lemmings" } <a id="CO247-1"></a><i class="conum" data-value="1"></i>
                },
                "the_movavg":{
                    "moving_avg":{ "buckets_path": "the_sum" } <a id="CO247-2"></a><i class="conum" data-value="2"></i>
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/544.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO247-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>该指标被称为<code class="literal">"the_sum"</code></p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO247-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">buckets_path</code>通过相对路径<code class="literal">"the_sum"</code>引用指标</p>
</td>
</tr>
</table>
</div>
<p>
<code class="literal">buckets_path</code>还用于 Sibling 管道聚合，其中聚合位于一系列桶的“旁边”,而不是嵌入在桶的“内部”。

例如，<code class="literal">max_bucket</code>聚合使用<code class="literal">buckets_path</code>来指定嵌入在 Sibling 聚合中的指标：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /_search
{
    "aggs" : {
        "sales_per_month" : {
            "date_histogram" : {
                "field" : "date",
                "calendar_interval" : "month"
            },
            "aggs": {
                "sales": {
                    "sum": {
                        "field": "price"
                    }
                }
            }
        },
        "max_monthly_sales": {
            "max_bucket": {
                "buckets_path": "sales_per_month&gt;sales" <a id="CO248-1"></a><i class="conum" data-value="1"></i>
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/545.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO248-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">buckets_path</code>指示 max_bucket 聚合，我们需要<code class="literal">sales_per_month</code>日期直方图中<code class="literal">sales</code>聚合的最大值。</p>
</td>
</tr>
</table>
</div>
<p>
如果 Sibling 管道聚合引用一个多桶聚合，如<code class="literal">terms</code>聚合，它还可以选择从多桶中选择特定的键。

例如，<code class="literal">bucket_script</code>可以(通过它们的桶的键)选择两个特定的桶来执行计算:
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /_search
{
    "aggs" : {
        "sales_per_month" : {
            "date_histogram" : {
                "field" : "date",
                "calendar_interval" : "month"
            },
            "aggs": {
                "sale_type": {
                    "terms": {
                        "field": "type"
                    },
                    "aggs": {
                        "sales": {
                            "sum": {
                                "field": "price"
                            }
                        }
                    }
                },
                "hat_vs_bag_ratio": {
                    "bucket_script": {
                        "buckets_path": {
                            "hats": "sale_type['hat']&gt;sales", <a id="CO249-1"></a><i class="conum" data-value="1"></i>
                            "bags": "sale_type['bag']&gt;sales"  <a id="CO249-2"></a><i class="conum" data-value="1"></i>
                        },
                        "script": "params.hats / params.bags"
                    }
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/546.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO249-1"><i class="conum" data-value="1"></i></a><a href="#CO249-2"></a></p>
</td>
<td align="left" valign="top">
<p>
<code class="literal">buckets_path</code>选择 hats 和 bags 桶(通过<code class="literal">['hat']</code>/<code class="literal">['bag']`</code>)专门在脚本中使用，而不是从<code class="literal">sale_type</code>聚合中获取所有桶
</p>
</td>
</tr>
</table>
</div>
<h3>
<a id="_special_paths"></a>特殊的路径
</h3>
<p>
<code class="literal">buckets_path</code>可以使用一个特殊的<code class="literal">"_count"</code>路径，而不是一个指标的路径。

这将指示管道聚合使用文档数量作为其输入。

例如，可以根据每个时段的文档数计算移动平均值(moving_avg)，而不是特定的指标：
</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /_search
{
    "aggs": {
        "my_date_histo": {
            "date_histogram": {
                "field":"timestamp",
                "calendar_interval":"day"
            },
            "aggs": {
                "the_movavg": {
                    "moving_avg": { "buckets_path": "_count" } <a id="CO250-1"></a><i class="conum" data-value="1"></i>
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/547.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO250-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>By using <code class="literal">_count</code> instead of a metric name, we can calculate the moving average of document counts in the histogram</p>
</td>
</tr>
</table>
</div>
<p>The <code class="literal">buckets_path</code> can also use <code class="literal">"_bucket_count"</code> and path to a multi-bucket aggregation to use the number of buckets
returned by that aggregation in the pipeline aggregation instead of a metric. for example a <code class="literal">bucket_selector</code> can be
used here to filter out buckets which contain no buckets for an inner terms aggregation:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /sales/_search
{
  "size": 0,
  "aggs": {
    "histo": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "day"
      },
      "aggs": {
        "categories": {
          "terms": {
            "field": "category"
          }
        },
        "min_bucket_selector": {
          "bucket_selector": {
            "buckets_path": {
              "count": "categories._bucket_count" <a id="CO251-1"></a><i class="conum" data-value="1"></i>
            },
            "script": {
              "source": "params.count != 0"
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/548.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO251-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>By using <code class="literal">_bucket_count</code> instead of a metric name, we can filter out <code class="literal">histo</code> buckets where they contain no buckets
for the <code class="literal">categories</code> aggregation</p>
</td>
</tr>
</table>
</div>
<h3>
<a id="dots-in-agg-names"></a>Dealing with dots in agg names<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/pipeline.asciidoc">edit</a>
</h3>
<p>An alternate syntax is supported to cope with aggregations or metrics which
have dots in the name, such as the <code class="literal">99.9</code>th
<a class="xref" href="search-aggregations-metrics-percentile-aggregation.html" title="Percentiles Aggregation">percentile</a>. This metric
may be referred to as:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"buckets_path": "my_percentile[99.9]"</pre>
</div>
<h3>
<a id="gap-policy"></a>Dealing with gaps in the data<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/7.7/docs/reference/aggregations/pipeline.asciidoc">edit</a>
</h3>
<p>Data in the real world is often noisy and sometimes contains <span class="strong strong"><strong>gaps</strong></span> — places where data simply doesn’t exist.  This can
occur for a variety of reasons, the most common being:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Documents falling into a bucket do not contain a required field
</li>
<li class="listitem">
There are no documents matching the query for one or more buckets
</li>
<li class="listitem">
The metric being calculated is unable to generate a value, likely because another dependent bucket is missing a value.
Some pipeline aggregations have specific requirements that must be met (e.g. a derivative cannot calculate a metric for the
first value because there is no previous value, HoltWinters moving average need "warmup" data to begin calculating, etc)
</li>
</ul>
</div>
<p>Gap policies are a mechanism to inform the pipeline aggregation about the desired behavior when "gappy" or missing
data is encountered.  All pipeline aggregations accept the <code class="literal">gap_policy</code> parameter.  There are currently two gap policies
to choose from:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<em>skip</em>
</span>
</dt>
<dd>
This option treats missing data as if the bucket does not exist.  It will skip the bucket and continue
calculating using the next available value.
</dd>
<dt>
<span class="term">
<em>insert_zeros</em>
</span>
</dt>
<dd>
This option will replace missing values with a zero (<code class="literal">0</code>) and pipeline aggregation computation will
proceed as normal.
</dd>
</dl>
</div>
















</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations-bucket-range-field-note.html">« 给范围字段分桶的微妙之处</a>
</span>
<span class="next">
<a href2="search-aggregations-pipeline-bucket-script-aggregation.html">Bucket Script Aggregation »</a>
</span>
</div>
</div>

                  <!-- end body -->
                        </div>
                        <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                        
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </section>
</div>
<script src="../static/cn.js"></script>
</body>
</html>